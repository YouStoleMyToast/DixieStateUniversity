//
// The Open Toolkit Library License
//
// Copyright (c) 2006 - 2013 Stefanos Apostolopoulos for the Open Toolkit Library
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to 
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//



namespace OpenTK.Graphics.ES30
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;
    #pragma warning disable 3019
    #pragma warning disable 1591
    #pragma warning disable 1572
    #pragma warning disable 1573

    partial class GL
    {

        public static partial class Amd
        {
            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glBeginPerfMonitorAMD")]
            public static 
            void BeginPerfMonitor(Int32 monitor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginPerfMonitorAMD((UInt32)monitor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glBeginPerfMonitorAMD")]
            public static 
            void BeginPerfMonitor(UInt32 monitor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginPerfMonitorAMD((UInt32)monitor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitor(Int32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* monitors_ptr = (UInt32*)&monitors;
                    Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitor(UInt32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* monitors_ptr = (UInt32*)&monitors;
                    Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitors(Int32 n, Int32[] monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* monitors_ptr = monitors)
                    {
                        Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitors(Int32 n, ref Int32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* monitors_ptr = &monitors)
                    {
                        Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            unsafe void DeletePerfMonitors(Int32 n, Int32* monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitors(Int32 n, UInt32[] monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* monitors_ptr = monitors)
                    {
                        Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            void DeletePerfMonitors(Int32 n, ref UInt32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* monitors_ptr = &monitors)
                    {
                        Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static 
            unsafe void DeletePerfMonitors(Int32 n, UInt32* monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glEndPerfMonitorAMD")]
            public static 
            void EndPerfMonitor(Int32 monitor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndPerfMonitorAMD((UInt32)monitor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glEndPerfMonitorAMD")]
            public static 
            void EndPerfMonitor(UInt32 monitor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndPerfMonitorAMD((UInt32)monitor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            Int32 GenPerfMonitor()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    Int32 retval;
                    Int32* monitors_ptr = &retval;
                    Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            void GenPerfMonitors(Int32 n, [OutAttribute] Int32[] monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* monitors_ptr = monitors)
                    {
                        Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            void GenPerfMonitors(Int32 n, [OutAttribute] out Int32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* monitors_ptr = &monitors)
                    {
                        Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        monitors = *monitors_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            unsafe void GenPerfMonitors(Int32 n, [OutAttribute] Int32* monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            void GenPerfMonitors(Int32 n, [OutAttribute] UInt32[] monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* monitors_ptr = monitors)
                    {
                        Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            void GenPerfMonitors(Int32 n, [OutAttribute] out UInt32 monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* monitors_ptr = &monitors)
                    {
                        Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        monitors = *monitors_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGenPerfMonitorsAMD")]
            public static 
            unsafe void GenPerfMonitors(Int32 n, [OutAttribute] UInt32* monitors)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] Int32[] data, [OutAttribute] out Int32 bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = data)
                    fixed (Int32* bytesWritten_ptr = &bytesWritten)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                        bytesWritten = *bytesWritten_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] out Int32 data, [OutAttribute] out Int32 bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = &data)
                    fixed (Int32* bytesWritten_ptr = &bytesWritten)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                        data = *data_ptr;
                        bytesWritten = *bytesWritten_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] Int32* data, [OutAttribute] Int32* bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data, (Int32*)bytesWritten);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] UInt32[] data, [OutAttribute] out Int32 bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* data_ptr = data)
                    fixed (Int32* bytesWritten_ptr = &bytesWritten)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                        bytesWritten = *bytesWritten_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] out UInt32 data, [OutAttribute] out Int32 bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* data_ptr = &data)
                    fixed (Int32* bytesWritten_ptr = &bytesWritten)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                        data = *data_ptr;
                        bytesWritten = *bytesWritten_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static 
            unsafe void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.ES30.All pname, Int32 dataSize, [OutAttribute] UInt32* data, [OutAttribute] Int32* bytesWritten)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.ES30.All)pname, (Int32)dataSize, (UInt32*)data, (Int32*)bytesWritten);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo(Int32 group, Int32 counter, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T3)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo(UInt32 group, UInt32 counter, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static 
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.ES30.All)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T3)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            void GetPerfMonitorCounters(Int32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] Int32[] counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numCounters_ptr = &numCounters)
                    fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                    fixed (Int32* counters_ptr = counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                        numCounters = *numCounters_ptr;
                        maxActiveCounters = *maxActiveCounters_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            void GetPerfMonitorCounters(Int32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] out Int32 counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numCounters_ptr = &numCounters)
                    fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                    fixed (Int32* counters_ptr = &counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                        numCounters = *numCounters_ptr;
                        maxActiveCounters = *maxActiveCounters_ptr;
                        counters = *counters_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            unsafe void GetPerfMonitorCounters(Int32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] Int32* counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            void GetPerfMonitorCounters(UInt32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] UInt32[] counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numCounters_ptr = &numCounters)
                    fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                    fixed (UInt32* counters_ptr = counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                        numCounters = *numCounters_ptr;
                        maxActiveCounters = *maxActiveCounters_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            void GetPerfMonitorCounters(UInt32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] out UInt32 counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numCounters_ptr = &numCounters)
                    fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                    fixed (UInt32* counters_ptr = &counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                        numCounters = *numCounters_ptr;
                        maxActiveCounters = *maxActiveCounters_ptr;
                        counters = *counters_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static 
            unsafe void GetPerfMonitorCounters(UInt32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] UInt32* counters)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static 
            void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder counterString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)counterString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static 
            unsafe void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder counterString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length, (StringBuilder)counterString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static 
            void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder counterString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)counterString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static 
            unsafe void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder counterString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length, (StringBuilder)counterString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            void GetPerfMonitorGroups([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] Int32[] groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numGroups_ptr = &numGroups)
                    fixed (Int32* groups_ptr = groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                        numGroups = *numGroups_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            void GetPerfMonitorGroups([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out Int32 groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numGroups_ptr = &numGroups)
                    fixed (Int32* groups_ptr = &groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                        numGroups = *numGroups_ptr;
                        groups = *groups_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            void GetPerfMonitorGroups([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] UInt32[] groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numGroups_ptr = &numGroups)
                    fixed (UInt32* groups_ptr = groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                        numGroups = *numGroups_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            void GetPerfMonitorGroups([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out UInt32 groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* numGroups_ptr = &numGroups)
                    fixed (UInt32* groups_ptr = &groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                        numGroups = *numGroups_ptr;
                        groups = *groups_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            unsafe void GetPerfMonitorGroups([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] Int32* groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static 
            unsafe void GetPerfMonitorGroups([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] UInt32* groups)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static 
            void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder groupString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)groupString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static 
            unsafe void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder groupString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length, (StringBuilder)groupString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static 
            void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder groupString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)groupString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static 
            unsafe void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder groupString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length, (StringBuilder)groupString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] Int32[] counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* counterList_ptr = counterList)
                    {
                        Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] out Int32 counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* counterList_ptr = &counterList)
                    {
                        Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                        counterList = *counterList_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            unsafe void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] Int32* counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] UInt32[] counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* counterList_ptr = counterList)
                    {
                        Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] out UInt32 counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* counterList_ptr = &counterList)
                    {
                        Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                        counterList = *counterList_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: AMD_performance_monitor]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AMD_performance_monitor", Version = "", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static 
            unsafe void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] UInt32* counterList)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Angle
        {
            /// <summary>[requires: ANGLE_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// <para>
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </para>
            /// </param>
            /// <param name="dstX0">
            /// <para>
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
            /// </para>
            /// </param>
            /// <param name="filter">
            /// <para>
            /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferANGLE")]
            public static 
            void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.All mask, OpenTK.Graphics.ES30.All filter)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlitFramebufferANGLE((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// <para>
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </para>
            /// </param>
            /// <param name="dstX0">
            /// <para>
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
            /// </para>
            /// </param>
            /// <param name="filter">
            /// <para>
            /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferANGLE")]
            public static 
            void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.ClearBufferMask mask, OpenTK.Graphics.ES30.BlitFramebufferFilter filter)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlitFramebufferANGLE((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedANGLE")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.All mode, Int32 first, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedANGLE")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 first, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedANGLE")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedANGLE((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length_ptr, (StringBuilder)source);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length_ptr, (StringBuilder)source);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            unsafe void GetTranslatedShaderSource(Int32 shader, Int32 bufsize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length, (StringBuilder)source);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length_ptr, (StringBuilder)source);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length_ptr, (StringBuilder)source);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_translated_shader_source]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ANGLE_translated_shader_source", Version = "", EntryPoint = "glGetTranslatedShaderSourceANGLE")]
            public static 
            unsafe void GetTranslatedShaderSource(UInt32 shader, Int32 bufsize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetTranslatedShaderSourceANGLE((UInt32)shader, (Int32)bufsize, (Int32*)length, (StringBuilder)source);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "ANGLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleANGLE")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleANGLE((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleANGLE")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleANGLE((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorANGLE")]
            public static 
            void VertexAttribDivisor(Int32 index, Int32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorANGLE((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: ANGLE_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ANGLE_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorANGLE")]
            public static 
            void VertexAttribDivisor(UInt32 index, UInt32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorANGLE((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Apple
        {
            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// The sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            public static 
            OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, Int64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glClientWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// The sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            public static 
            OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, UInt64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glClientWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// The sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            public static 
            OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.ClientWaitSyncFlags flags, Int64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glClientWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Block and wait for a sync object to become signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// The sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glClientWaitSyncAPPLE")]
            public static 
            OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.ClientWaitSyncFlags flags, UInt64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glClientWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_copy_texture_levels]</summary>
            [AutoGenerated(Category = "APPLE_copy_texture_levels", Version = "", EntryPoint = "glCopyTextureLevelsAPPLE")]
            public static 
            void CopyTextureLevel(Int32 destinationTexture, Int32 sourceTexture, Int32 sourceBaseLevel, Int32 sourceLevelCount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyTextureLevelsAPPLE((UInt32)destinationTexture, (UInt32)sourceTexture, (Int32)sourceBaseLevel, (Int32)sourceLevelCount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_copy_texture_levels]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_copy_texture_levels", Version = "", EntryPoint = "glCopyTextureLevelsAPPLE")]
            public static 
            void CopyTextureLevel(UInt32 destinationTexture, UInt32 sourceTexture, Int32 sourceBaseLevel, Int32 sourceLevelCount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyTextureLevelsAPPLE((UInt32)destinationTexture, (UInt32)sourceTexture, (Int32)sourceBaseLevel, (Int32)sourceLevelCount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Delete a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// The sync object to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glDeleteSyncAPPLE")]
            public static 
            void DeleteSync(IntPtr sync)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteSyncAPPLE((IntPtr)sync);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Create a new sync object and insert it into the GL command stream
            /// </summary>
            /// <param name="condition">
            /// <para>
            /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glFenceSyncAPPLE")]
            public static 
            IntPtr FenceSync(OpenTK.Graphics.ES30.All condition, OpenTK.Graphics.ES30.All flags)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glFenceSyncAPPLE((OpenTK.Graphics.ES30.SyncCondition)condition, (OpenTK.Graphics.ES30.WaitSyncFlags)flags);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Create a new sync object and insert it into the GL command stream
            /// </summary>
            /// <param name="condition">
            /// <para>
            /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glFenceSyncAPPLE")]
            public static 
            IntPtr FenceSync(OpenTK.Graphics.ES30.SyncCondition condition, OpenTK.Graphics.ES30.WaitSyncFlags flags)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glFenceSyncAPPLE((OpenTK.Graphics.ES30.SyncCondition)condition, (OpenTK.Graphics.ES30.WaitSyncFlags)flags);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            Int64 GetInteger64(OpenTK.Graphics.ES30.All pname)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    Int64 retval;
                    Int64* @params_ptr = &retval;
                    Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            Int64 GetInteger64(OpenTK.Graphics.ES30.GetPName pname)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    Int64 retval;
                    Int64* @params_ptr = &retval;
                    Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            unsafe void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetInteger64vAPPLE")]
            public static 
            unsafe void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetInteger64vAPPLE((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] Int32[] values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (Int32* values_ptr = values)
                    {
                        Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (Int32* values_ptr = &values)
                    {
                        Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                        length = *length_ptr;
                        values = *values_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length, (Int32*)values);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] Int32[] values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (Int32* values_ptr = values)
                    {
                        Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (Int32* values_ptr = &values)
                    {
                        Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                        length = *length_ptr;
                        values = *values_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Query the properties of a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose properties to query.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given in values.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of an variable to receive the number of integers placed in values.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// Specifies the address of an array to receive the values of the queried parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glGetSyncivAPPLE")]
            public static 
            unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* values)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetSyncivAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length, (Int32*)values);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Determine if a name corresponds to a sync object
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies a value that may be the name of a sync object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glIsSyncAPPLE")]
            public static 
            bool IsSync(IntPtr sync)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsSyncAPPLE((IntPtr)sync);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "APPLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleAPPLE")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleAPPLE((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleAPPLE")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleAPPLE((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_framebuffer_multisample]</summary>
            [AutoGenerated(Category = "APPLE_framebuffer_multisample", Version = "", EntryPoint = "glResolveMultisampleFramebufferAPPLE")]
            public static 
            void ResolveMultisampleFramebuffer()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glResolveMultisampleFramebufferAPPLE();
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be zero.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            public static 
            void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, Int64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be zero.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            public static 
            void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, UInt64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be zero.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            public static 
            void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.WaitSyncFlags flags, Int64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: APPLE_sync]
            /// Instruct the GL server to block until the specified sync object becomes signaled
            /// </summary>
            /// <param name="sync">
            /// <para>
            /// Specifies the sync object whose status to wait on.
            /// </para>
            /// </param>
            /// <param name="flags">
            /// <para>
            /// A bitfield controlling the command flushing behavior. flags may be zero.
            /// </para>
            /// </param>
            /// <param name="timeout">
            /// <para>
            /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "APPLE_sync", Version = "", EntryPoint = "glWaitSyncAPPLE")]
            public static 
            void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.WaitSyncFlags flags, UInt64 timeout)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glWaitSyncAPPLE((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
                #if DEBUG
                }
                #endif
            }

        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Select active texture unit
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from 0 (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glActiveTexture")]
        public static 
        void ActiveTexture(OpenTK.Graphics.ES30.All texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glActiveTexture((OpenTK.Graphics.ES30.TextureUnit)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Select active texture unit
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from 0 (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glActiveTexture")]
        public static 
        void ActiveTexture(OpenTK.Graphics.ES30.TextureUnit texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glActiveTexture((OpenTK.Graphics.ES30.TextureUnit)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attaches a shader object to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to which a shader object will be attached.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object that is to be attached.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glAttachShader")]
        public static 
        void AttachShader(Int32 program, Int32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glAttachShader((UInt32)program, (UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attaches a shader object to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to which a shader object will be attached.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object that is to be attached.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glAttachShader")]
        public static 
        void AttachShader(UInt32 program, UInt32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glAttachShader((UInt32)program, (UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        public static 
        void BeginQuery(OpenTK.Graphics.ES30.All target, Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginQuery((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        public static 
        void BeginQuery(OpenTK.Graphics.ES30.All target, UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginQuery((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        public static 
        void BeginQuery(OpenTK.Graphics.ES30.QueryTarget target, Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginQuery((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delimit the boundaries of a query object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginQuery")]
        public static 
        void BeginQuery(OpenTK.Graphics.ES30.QueryTarget target, UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginQuery((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Start transform feedback operation
        /// </summary>
        /// <param name="primitiveMode">
        /// <para>
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginTransformFeedback")]
        public static 
        void BeginTransformFeedback(OpenTK.Graphics.ES30.All primitiveMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackPrimitiveType)primitiveMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Start transform feedback operation
        /// </summary>
        /// <param name="primitiveMode">
        /// <para>
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBeginTransformFeedback")]
        public static 
        void BeginTransformFeedback(OpenTK.Graphics.ES30.TransformFeedbackPrimitiveType primitiveMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBeginTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackPrimitiveType)primitiveMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Associates a generic vertex attribute index with a named attribute variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object in which the association is to be made.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindAttribLocation")]
        public static 
        void BindAttribLocation(Int32 program, Int32 index, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindAttribLocation((UInt32)program, (UInt32)index, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Associates a generic vertex attribute index with a named attribute variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object in which the association is to be made.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindAttribLocation")]
        public static 
        void BindAttribLocation(UInt32 program, UInt32 index, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindAttribLocation((UInt32)program, (UInt32)index, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Specifies the name of a buffer object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        public static 
        void BindBuffer(OpenTK.Graphics.ES30.All target, Int32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBuffer((OpenTK.Graphics.ES30.BufferTarget)target, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Specifies the name of a buffer object.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        public static 
        void BindBuffer(OpenTK.Graphics.ES30.All target, UInt32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBuffer((OpenTK.Graphics.ES30.BufferTarget)target, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Specifies the name of a buffer object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        public static 
        void BindBuffer(OpenTK.Graphics.ES30.BufferTarget target, Int32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBuffer((OpenTK.Graphics.ES30.BufferTarget)target, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Specifies the name of a buffer object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindBuffer")]
        public static 
        void BindBuffer(OpenTK.Graphics.ES30.BufferTarget target, UInt32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBuffer((OpenTK.Graphics.ES30.BufferTarget)target, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        public static 
        void BindBufferBase(OpenTK.Graphics.ES30.All target, Int32 index, Int32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferBase((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        public static 
        void BindBufferBase(OpenTK.Graphics.ES30.All target, UInt32 index, UInt32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferBase((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        public static 
        void BindBufferBase(OpenTK.Graphics.ES30.BufferRangeTarget target, Int32 index, Int32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferBase((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferBase")]
        public static 
        void BindBufferBase(OpenTK.Graphics.ES30.BufferRangeTarget target, UInt32 index, UInt32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferBase((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        public static 
        void BindBufferRange(OpenTK.Graphics.ES30.All target, Int32 index, Int32 buffer, IntPtr offset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferRange((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        public static 
        void BindBufferRange(OpenTK.Graphics.ES30.All target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferRange((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        public static 
        void BindBufferRange(OpenTK.Graphics.ES30.BufferRangeTarget target, Int32 index, Int32 buffer, IntPtr offset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferRange((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a range within a buffer object to an indexed buffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specify the index of the binding point within the array specified by target.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// The name of a buffer object to bind to the specified binding point.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The amount of data in machine units that can be read from the buffet object while used as an indexed target.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindBufferRange")]
        public static 
        void BindBufferRange(OpenTK.Graphics.ES30.BufferRangeTarget target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindBufferRange((OpenTK.Graphics.ES30.BufferRangeTarget)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target of the binding operation.
        /// </para>
        /// </param>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies the name of the framebuffer object to bind.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        public static 
        void BindFramebuffer(OpenTK.Graphics.ES30.All target, Int32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target of the binding operation.
        /// </para>
        /// </param>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies the name of the framebuffer object to bind.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        public static 
        void BindFramebuffer(OpenTK.Graphics.ES30.All target, UInt32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target of the binding operation.
        /// </para>
        /// </param>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies the name of the framebuffer object to bind.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        public static 
        void BindFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a framebuffer to a framebuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target of the binding operation.
        /// </para>
        /// </param>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies the name of the framebuffer object to bind.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindFramebuffer")]
        public static 
        void BindFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, UInt32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of the renderbuffer object to bind.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        public static 
        void BindRenderbuffer(OpenTK.Graphics.ES30.All target, Int32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindRenderbuffer((OpenTK.Graphics.ES30.RenderbufferTarget)target, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of the renderbuffer object to bind.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        public static 
        void BindRenderbuffer(OpenTK.Graphics.ES30.All target, UInt32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindRenderbuffer((OpenTK.Graphics.ES30.RenderbufferTarget)target, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of the renderbuffer object to bind.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        public static 
        void BindRenderbuffer(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindRenderbuffer((OpenTK.Graphics.ES30.RenderbufferTarget)target, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a renderbuffer to a renderbuffer target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of the renderbuffer object to bind.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindRenderbuffer")]
        public static 
        void BindRenderbuffer(OpenTK.Graphics.ES30.RenderbufferTarget target, UInt32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindRenderbuffer((OpenTK.Graphics.ES30.RenderbufferTarget)target, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a named sampler to a texturing target
        /// </summary>
        /// <param name="unit">
        /// <para>
        /// Specifies the index of the texture unit to which the sampler is bound.
        /// </para>
        /// </param>
        /// <param name="sampler">
        /// <para>
        /// Specifies the name of a sampler.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindSampler")]
        public static 
        void BindSampler(Int32 unit, Int32 sampler)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindSampler((UInt32)unit, (UInt32)sampler);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a named sampler to a texturing target
        /// </summary>
        /// <param name="unit">
        /// <para>
        /// Specifies the index of the texture unit to which the sampler is bound.
        /// </para>
        /// </param>
        /// <param name="sampler">
        /// <para>
        /// Specifies the name of a sampler.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindSampler")]
        public static 
        void BindSampler(UInt32 unit, UInt32 sampler)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindSampler((UInt32)unit, (UInt32)sampler);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        public static 
        void BindTexture(OpenTK.Graphics.ES30.All target, Int32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTexture((OpenTK.Graphics.ES30.TextureTarget)target, (UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        public static 
        void BindTexture(OpenTK.Graphics.ES30.All target, UInt32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTexture((OpenTK.Graphics.ES30.TextureTarget)target, (UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        public static 
        void BindTexture(OpenTK.Graphics.ES30.TextureTarget target, Int32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTexture((OpenTK.Graphics.ES30.TextureTarget)target, (UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBindTexture")]
        public static 
        void BindTexture(OpenTK.Graphics.ES30.TextureTarget target, UInt32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTexture((OpenTK.Graphics.ES30.TextureTarget)target, (UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        public static 
        void BindTransformFeedback(OpenTK.Graphics.ES30.All target, Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        public static 
        void BindTransformFeedback(OpenTK.Graphics.ES30.All target, UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        public static 
        void BindTransformFeedback(OpenTK.Graphics.ES30.TransformFeedbackTarget target, Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a transform feedback object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindTransformFeedback")]
        public static 
        void BindTransformFeedback(OpenTK.Graphics.ES30.TransformFeedbackTarget target, UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindTransformFeedback((OpenTK.Graphics.ES30.TransformFeedbackTarget)target, (UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a vertex array object
        /// </summary>
        /// <param name="array">
        /// <para>
        /// Specifies the name of the vertex array to bind.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindVertexArray")]
        public static 
        void BindVertexArray(Int32 array)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindVertexArray((UInt32)array);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Bind a vertex array object
        /// </summary>
        /// <param name="array">
        /// <para>
        /// Specifies the name of the vertex array to bind.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBindVertexArray")]
        public static 
        void BindVertexArray(UInt32 array)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBindVertexArray((UInt32)array);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set the blend color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// specify the components of GL_BLEND_COLOR
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendColor")]
        public static 
        void BlendColor(Single red, Single green, Single blue, Single alpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendColor((Single)red, (Single)green, (Single)blue, (Single)alpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquation")]
        public static 
        void BlendEquation(OpenTK.Graphics.ES30.All mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendEquation((OpenTK.Graphics.ES30.BlendEquationMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquation")]
        public static 
        void BlendEquation(OpenTK.Graphics.ES30.BlendEquationMode mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendEquation((OpenTK.Graphics.ES30.BlendEquationMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set the RGB blend equation and the alpha blend equation separately
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations.
        /// </para>
        /// </param>
        /// <param name="modeRGB">
        /// <para>
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        /// <param name="modeAlpha">
        /// <para>
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquationSeparate")]
        public static 
        void BlendEquationSeparate(OpenTK.Graphics.ES30.All modeRGB, OpenTK.Graphics.ES30.All modeAlpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendEquationSeparate((OpenTK.Graphics.ES30.BlendEquationMode)modeRGB, (OpenTK.Graphics.ES30.BlendEquationMode)modeAlpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set the RGB blend equation and the alpha blend equation separately
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations.
        /// </para>
        /// </param>
        /// <param name="modeRGB">
        /// <para>
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        /// <param name="modeAlpha">
        /// <para>
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendEquationSeparate")]
        public static 
        void BlendEquationSeparate(OpenTK.Graphics.ES30.BlendEquationMode modeRGB, OpenTK.Graphics.ES30.BlendEquationMode modeAlpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendEquationSeparate((OpenTK.Graphics.ES30.BlendEquationMode)modeRGB, (OpenTK.Graphics.ES30.BlendEquationMode)modeAlpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// For glBlendFunci, specifies the index of the draw buffer for which to set the blend function.
        /// </para>
        /// </param>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFunc")]
        public static 
        void BlendFunc(OpenTK.Graphics.ES30.All sfactor, OpenTK.Graphics.ES30.All dfactor)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendFunc((OpenTK.Graphics.ES30.BlendingFactorSrc)sfactor, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactor);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// For glBlendFunci, specifies the index of the draw buffer for which to set the blend function.
        /// </para>
        /// </param>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFunc")]
        public static 
        void BlendFunc(OpenTK.Graphics.ES30.BlendingFactorSrc sfactor, OpenTK.Graphics.ES30.BlendingFactorDest dfactor)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendFunc((OpenTK.Graphics.ES30.BlendingFactorSrc)sfactor, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactor);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify pixel arithmetic for RGB and alpha components separately
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions.
        /// </para>
        /// </param>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFuncSeparate")]
        public static 
        void BlendFuncSeparate(OpenTK.Graphics.ES30.All sfactorRGB, OpenTK.Graphics.ES30.All dfactorRGB, OpenTK.Graphics.ES30.All sfactorAlpha, OpenTK.Graphics.ES30.All dfactorAlpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendFuncSeparate((OpenTK.Graphics.ES30.BlendingFactorSrc)sfactorRGB, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactorRGB, (OpenTK.Graphics.ES30.BlendingFactorSrc)sfactorAlpha, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactorAlpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify pixel arithmetic for RGB and alpha components separately
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions.
        /// </para>
        /// </param>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBlendFuncSeparate")]
        public static 
        void BlendFuncSeparate(OpenTK.Graphics.ES30.BlendingFactorSrc sfactorRGB, OpenTK.Graphics.ES30.BlendingFactorDest dfactorRGB, OpenTK.Graphics.ES30.BlendingFactorSrc sfactorAlpha, OpenTK.Graphics.ES30.BlendingFactorDest dfactorAlpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlendFuncSeparate((OpenTK.Graphics.ES30.BlendingFactorSrc)sfactorRGB, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactorRGB, (OpenTK.Graphics.ES30.BlendingFactorSrc)sfactorAlpha, (OpenTK.Graphics.ES30.BlendingFactorDest)dfactorAlpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy a block of pixels from the read framebuffer to the draw framebuffer
        /// </summary>
        /// <param name="srcX0">
        /// <para>
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </para>
        /// </param>
        /// <param name="dstX0">
        /// <para>
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </para>
        /// </param>
        /// <param name="filter">
        /// <para>
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBlitFramebuffer")]
        public static 
        void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.All mask, OpenTK.Graphics.ES30.All filter)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlitFramebuffer((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy a block of pixels from the read framebuffer to the draw framebuffer
        /// </summary>
        /// <param name="srcX0">
        /// <para>
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </para>
        /// </param>
        /// <param name="dstX0">
        /// <para>
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </para>
        /// </param>
        /// <param name="filter">
        /// <para>
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glBlitFramebuffer")]
        public static 
        void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.ClearBufferMask mask, OpenTK.Graphics.ES30.BlitFramebufferFilter filter)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBlitFramebuffer((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData(OpenTK.Graphics.ES30.All target, IntPtr size, IntPtr data, OpenTK.Graphics.ES30.All usage)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data, (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.All target, IntPtr size, [InAttribute, OutAttribute] T2[] data, OpenTK.Graphics.ES30.All usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.All target, IntPtr size, [InAttribute, OutAttribute] T2[,] data, OpenTK.Graphics.ES30.All usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.All target, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, OpenTK.Graphics.ES30.All usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.All target, IntPtr size, [InAttribute, OutAttribute] ref T2 data, OpenTK.Graphics.ES30.All usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
                data = (T2)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData(OpenTK.Graphics.ES30.BufferTarget target, IntPtr size, IntPtr data, OpenTK.Graphics.ES30.BufferUsageHint usage)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data, (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr size, [InAttribute, OutAttribute] T2[] data, OpenTK.Graphics.ES30.BufferUsageHint usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr size, [InAttribute, OutAttribute] T2[,] data, OpenTK.Graphics.ES30.BufferUsageHint usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, OpenTK.Graphics.ES30.BufferUsageHint usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates and initializes a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferData")]
        public static 
        void BufferData<T2>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr size, [InAttribute, OutAttribute] ref T2 data, OpenTK.Graphics.ES30.BufferUsageHint usage)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.ES30.BufferUsageHint)usage);
                data = (T2)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr size, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T3)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr size, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Updates a subset of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size in bytes of the data store region being replaced.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glBufferSubData")]
        public static 
        void BufferSubData<T3>(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glBufferSubData((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T3)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Check the completeness status of a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the framebuffer completeness check.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCheckFramebufferStatus")]
        public static 
        OpenTK.Graphics.ES30.FramebufferErrorCode CheckFramebufferStatus(OpenTK.Graphics.ES30.All target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glCheckFramebufferStatus((OpenTK.Graphics.ES30.FramebufferTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Check the completeness status of a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the framebuffer completeness check.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCheckFramebufferStatus")]
        public static 
        OpenTK.Graphics.ES30.FramebufferErrorCode CheckFramebufferStatus(OpenTK.Graphics.ES30.FramebufferTarget target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glCheckFramebufferStatus((OpenTK.Graphics.ES30.FramebufferTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Clear buffers to preset values
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClear")]
        public static 
        void Clear(OpenTK.Graphics.ES30.All mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClear((OpenTK.Graphics.ES30.ClearBufferMask)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Clear buffers to preset values
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClear")]
        public static 
        void Clear(OpenTK.Graphics.ES30.ClearBufferMask mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClear((OpenTK.Graphics.ES30.ClearBufferMask)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfi")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, Single depth, Int32 stencil)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferfi((OpenTK.Graphics.ES30.ClearBufferCombined)buffer, (Int32)drawbuffer, (Single)depth, (Int32)stencil);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfi")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBufferCombined buffer, Int32 drawbuffer, Single depth, Int32 stencil)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferfi((OpenTK.Graphics.ES30.ClearBufferCombined)buffer, (Int32)drawbuffer, (Single)depth, (Int32)stencil);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferfv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferfv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, ref Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = &value)
                {
                    Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, ref Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = &value)
                {
                    Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferiv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.All buffer, Int32 drawbuffer, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Clear individual buffers of the currently bound draw framebuffer
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specify the buffer to clear.
        /// </para>
        /// </param>
        /// <param name="drawBuffer">
        /// <para>
        /// Specify a particular draw buffer to clear.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// The value to clear a depth render buffer to.
        /// </para>
        /// </param>
        /// <param name="stencil">
        /// <para>
        /// The value to clear a stencil render buffer to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClearBufferuiv")]
        public static 
        unsafe void ClearBuffer(OpenTK.Graphics.ES30.ClearBuffer buffer, Int32 drawbuffer, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearBufferuiv((OpenTK.Graphics.ES30.ClearBuffer)buffer, (Int32)drawbuffer, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify clear values for the color buffers
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearColor")]
        public static 
        void ClearColor(Single red, Single green, Single blue, Single alpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearColor((Single)red, (Single)green, (Single)blue, (Single)alpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the clear value for the depth buffer
        /// </summary>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearDepthf")]
        public static 
        void ClearDepth(Single d)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearDepthf((Single)d);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the clear value for the stencil buffer
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glClearStencil")]
        public static 
        void ClearStencil(Int32 s)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glClearStencil((Int32)s);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// The sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        public static 
        OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, Int64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glClientWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// The sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        public static 
        OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, UInt64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glClientWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// The sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        public static 
        OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.ClientWaitSyncFlags flags, Int64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glClientWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Block and wait for a sync object to become signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// The sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glClientWaitSync")]
        public static 
        OpenTK.Graphics.ES30.WaitSyncStatus ClientWaitSync(IntPtr sync, OpenTK.Graphics.ES30.ClientWaitSyncFlags flags, UInt64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glClientWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.ClientWaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable and disable writing of frame buffer color components
        /// </summary>
        /// <param name="buf">
        /// <para>
        /// For glColorMaski, specifies the index of the draw buffer whose color mask to set.
        /// </para>
        /// </param>
        /// <param name="red">
        /// <para>
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glColorMask")]
        public static 
        void ColorMask(bool red, bool green, bool blue, bool alpha)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glColorMask((bool)red, (bool)green, (bool)blue, (bool)alpha);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Compiles a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be compiled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompileShader")]
        public static 
        void CompileShader(Int32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompileShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Compiles a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be compiled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompileShader")]
        public static 
        void CompileShader(UInt32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompileShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T7)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexImage2D")]
        public static 
        void CompressedTexImage2D<T7>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 data)
            where T7 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T7)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T8)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexImage3D")]
        public static 
        void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T8)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T8)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCompressedTexSubImage2D")]
        public static 
        void CompressedTexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T8)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,,] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T10 data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T10)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, IntPtr data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[,] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[,,] data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the compressed image data stored at address data.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the compressed image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCompressedTexSubImage3D")]
        public static 
        void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T10 data)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
            try
            {
                Delegates.glCompressedTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                data = (T10)data_ptr.Target;
            }
            finally
            {
                data_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy part of the data store of a buffer object to the data store of another buffer object
        /// </summary>
        /// <param name="readtarget">
        /// <para>
        /// Specifies the target from whose data store data should be read.
        /// </para>
        /// </param>
        /// <param name="writetarget">
        /// <para>
        /// Specifies the target to whose data store data should be written.
        /// </para>
        /// </param>
        /// <param name="readoffset">
        /// <para>
        /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
        /// </para>
        /// </param>
        /// <param name="writeoffset">
        /// <para>
        /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyBufferSubData")]
        public static 
        void CopyBufferSubData(OpenTK.Graphics.ES30.All readTarget, OpenTK.Graphics.ES30.All writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyBufferSubData((OpenTK.Graphics.ES30.BufferTarget)readTarget, (OpenTK.Graphics.ES30.BufferTarget)writeTarget, (IntPtr)readOffset, (IntPtr)writeOffset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy part of the data store of a buffer object to the data store of another buffer object
        /// </summary>
        /// <param name="readtarget">
        /// <para>
        /// Specifies the target from whose data store data should be read.
        /// </para>
        /// </param>
        /// <param name="writetarget">
        /// <para>
        /// Specifies the target to whose data store data should be written.
        /// </para>
        /// </param>
        /// <param name="readoffset">
        /// <para>
        /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
        /// </para>
        /// </param>
        /// <param name="writeoffset">
        /// <para>
        /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyBufferSubData")]
        public static 
        void CopyBufferSubData(OpenTK.Graphics.ES30.BufferTarget readTarget, OpenTK.Graphics.ES30.BufferTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyBufferSubData((OpenTK.Graphics.ES30.BufferTarget)readTarget, (OpenTK.Graphics.ES30.BufferTarget)writeTarget, (IntPtr)readOffset, (IntPtr)writeOffset, (IntPtr)size);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Copy pixels into a 2D texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Must be 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexImage2D")]
        public static 
        void CopyTexImage2D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureCopyComponentCount)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Copy pixels into a 2D texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Must be 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexImage2D")]
        public static 
        void CopyTexImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureCopyComponentCount internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureCopyComponentCount)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexSubImage2D")]
        public static 
        void CopyTexSubImage2D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCopyTexSubImage2D")]
        public static 
        void CopyTexSubImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyTexSubImage3D")]
        public static 
        void CopyTexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Copy a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glCopyTexSubImage3D")]
        public static 
        void CopyTexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCopyTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates a program object
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCreateProgram")]
        public static 
        Int32 CreateProgram()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glCreateProgram();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates a shader object
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCreateShader")]
        public static 
        Int32 CreateShader(OpenTK.Graphics.ES30.All type)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glCreateShader((OpenTK.Graphics.ES30.ShaderType)type);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Creates a shader object
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCreateShader")]
        public static 
        Int32 CreateShader(OpenTK.Graphics.ES30.ShaderType type)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glCreateShader((OpenTK.Graphics.ES30.ShaderType)type);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify whether front- or back-facing facets can be culled
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCullFace")]
        public static 
        void CullFace(OpenTK.Graphics.ES30.All mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCullFace((OpenTK.Graphics.ES30.CullFaceMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify whether front- or back-facing facets can be culled
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glCullFace")]
        public static 
        void CullFace(OpenTK.Graphics.ES30.CullFaceMode mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glCullFace((OpenTK.Graphics.ES30.CullFaceMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// <para>
        /// The address of a callback function that will be called when a debug message is generated.
        /// </para>
        /// </param>
        /// <param name="userParam">
        /// <para>
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static 
        void DebugMessageCallback(DebugProc callback, IntPtr userParam)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageCallback((DebugProc)callback, (IntPtr)userParam);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// <para>
        /// The address of a callback function that will be called when a debug message is generated.
        /// </para>
        /// </param>
        /// <param name="userParam">
        /// <para>
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static 
        void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[] userParam)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
            try
            {
                Delegates.glDebugMessageCallback((DebugProc)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
            }
            finally
            {
                userParam_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// <para>
        /// The address of a callback function that will be called when a debug message is generated.
        /// </para>
        /// </param>
        /// <param name="userParam">
        /// <para>
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static 
        void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[,] userParam)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
            try
            {
                Delegates.glDebugMessageCallback((DebugProc)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
            }
            finally
            {
                userParam_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// <para>
        /// The address of a callback function that will be called when a debug message is generated.
        /// </para>
        /// </param>
        /// <param name="userParam">
        /// <para>
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static 
        void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] T1[,,] userParam)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
            try
            {
                Delegates.glDebugMessageCallback((DebugProc)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
            }
            finally
            {
                userParam_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Specify a callback to receive debugging messages from the GL
        /// </summary>
        /// <param name="callback">
        /// <para>
        /// The address of a callback function that will be called when a debug message is generated.
        /// </para>
        /// </param>
        /// <param name="userParam">
        /// <para>
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallback")]
        public static 
        void DebugMessageCallback<T1>(DebugProc callback, [InAttribute, OutAttribute] ref T1 userParam)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
            try
            {
                Delegates.glDebugMessageCallback((DebugProc)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
                userParam = (T1)userParam_ptr.Target;
            }
            finally
            {
                userParam_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, Int32[] ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, ref Int32 ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        unsafe void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, Int32* ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, UInt32[] ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, ref UInt32 ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        unsafe void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, UInt32* ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, Int32[] ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, ref Int32 ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        unsafe void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, Int32* ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, UInt32[] ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, ref UInt32 ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Control the reporting of debug messages in a debug context
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of debug messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The length of the array ids.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
        /// </para>
        /// </param>
        /// <param name="enabled">
        /// <para>
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControl")]
        public static 
        unsafe void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, UInt32* ids, bool enabled)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageControl((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message to insert.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the debug message insert.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The user-supplied identifier of the message to insert.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of the debug messages to insert.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length string contained in the character array whose address is given by message.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The address of a character array containing the message to insert.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        public static 
        void DebugMessageInsert(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, Int32 id, OpenTK.Graphics.ES30.All severity, Int32 length, String buf)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageInsert((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message to insert.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the debug message insert.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The user-supplied identifier of the message to insert.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of the debug messages to insert.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length string contained in the character array whose address is given by message.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The address of a character array containing the message to insert.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        public static 
        void DebugMessageInsert(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, UInt32 id, OpenTK.Graphics.ES30.All severity, Int32 length, String buf)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageInsert((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message to insert.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the debug message insert.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The user-supplied identifier of the message to insert.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of the debug messages to insert.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length string contained in the character array whose address is given by message.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The address of a character array containing the message to insert.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        public static 
        void DebugMessageInsert(OpenTK.Graphics.ES30.DebugSourceExternal source, OpenTK.Graphics.ES30.DebugType type, Int32 id, OpenTK.Graphics.ES30.DebugSeverity severity, Int32 length, String buf)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageInsert((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Inject an application-supplied message into the debug message queue
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message to insert.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the debug message insert.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The user-supplied identifier of the message to insert.
        /// </para>
        /// </param>
        /// <param name="severity">
        /// <para>
        /// The severity of the debug messages to insert.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length string contained in the character array whose address is given by message.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The address of a character array containing the message to insert.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsert")]
        public static 
        void DebugMessageInsert(OpenTK.Graphics.ES30.DebugSourceExternal source, OpenTK.Graphics.ES30.DebugType type, UInt32 id, OpenTK.Graphics.ES30.DebugSeverity severity, Int32 length, String buf)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDebugMessageInsert((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffer(Int32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* buffers_ptr = (UInt32*)&buffers;
                Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffer(UInt32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* buffers_ptr = (UInt32*)&buffers;
                Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffers(Int32 n, Int32[] buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* buffers_ptr = buffers)
                {
                    Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffers(Int32 n, ref Int32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* buffers_ptr = &buffers)
                {
                    Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        unsafe void DeleteBuffers(Int32 n, Int32* buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffers(Int32 n, UInt32[] buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* buffers_ptr = buffers)
                {
                    Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        void DeleteBuffers(Int32 n, ref UInt32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* buffers_ptr = &buffers)
                {
                    Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named buffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array of buffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteBuffers")]
        public static 
        unsafe void DeleteBuffers(Int32 n, UInt32* buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteBuffers((Int32)n, (UInt32*)buffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffer(Int32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* framebuffers_ptr = (UInt32*)&framebuffers;
                Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffer(UInt32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* framebuffers_ptr = (UInt32*)&framebuffers;
                Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffers(Int32 n, Int32[] framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* framebuffers_ptr = framebuffers)
                {
                    Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffers(Int32 n, ref Int32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* framebuffers_ptr = &framebuffers)
                {
                    Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        unsafe void DeleteFramebuffers(Int32 n, Int32* framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffers(Int32 n, UInt32[] framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* framebuffers_ptr = framebuffers)
                {
                    Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        void DeleteFramebuffers(Int32 n, ref UInt32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* framebuffers_ptr = &framebuffers)
                {
                    Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete framebuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="framebuffers">
        /// <para>
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteFramebuffers")]
        public static 
        unsafe void DeleteFramebuffers(Int32 n, UInt32* framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteFramebuffers((Int32)n, (UInt32*)framebuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Deletes a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteProgram")]
        public static 
        void DeleteProgram(Int32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Deletes a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteProgram")]
        public static 
        void DeleteProgram(UInt32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQuery(Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* ids_ptr = (UInt32*)&ids;
                Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQuery(UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* ids_ptr = (UInt32*)&ids;
                Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQueries(Int32 n, Int32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQueries(Int32 n, ref Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        unsafe void DeleteQueries(Int32 n, Int32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteQueries((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQueries(Int32 n, UInt32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        void DeleteQueries(Int32 n, ref UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glDeleteQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named query objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of query objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteQueries")]
        public static 
        unsafe void DeleteQueries(Int32 n, UInt32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteQueries((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffer(Int32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* renderbuffers_ptr = (UInt32*)&renderbuffers;
                Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffer(UInt32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* renderbuffers_ptr = (UInt32*)&renderbuffers;
                Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffers(Int32 n, Int32[] renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* renderbuffers_ptr = renderbuffers)
                {
                    Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffers(Int32 n, ref Int32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* renderbuffers_ptr = &renderbuffers)
                {
                    Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        unsafe void DeleteRenderbuffers(Int32 n, Int32* renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffers(Int32 n, UInt32[] renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* renderbuffers_ptr = renderbuffers)
                {
                    Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        void DeleteRenderbuffers(Int32 n, ref UInt32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* renderbuffers_ptr = &renderbuffers)
                {
                    Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete renderbuffer objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteRenderbuffers")]
        public static 
        unsafe void DeleteRenderbuffers(Int32 n, UInt32* renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteRenderbuffers((Int32)n, (UInt32*)renderbuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSampler(Int32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 count = 1;
                UInt32* samplers_ptr = (UInt32*)&samplers;
                Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSampler(UInt32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 count = 1;
                UInt32* samplers_ptr = (UInt32*)&samplers;
                Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSamplers(Int32 count, Int32[] samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* samplers_ptr = samplers)
                {
                    Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSamplers(Int32 count, ref Int32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* samplers_ptr = &samplers)
                {
                    Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        unsafe void DeleteSamplers(Int32 count, Int32* samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSamplers(Int32 count, UInt32[] samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* samplers_ptr = samplers)
                {
                    Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        void DeleteSamplers(Int32 count, ref UInt32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* samplers_ptr = &samplers)
                {
                    Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete named sampler objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array of sampler objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSamplers")]
        public static 
        unsafe void DeleteSamplers(Int32 count, UInt32* samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteSamplers((Int32)count, (UInt32*)samplers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Deletes a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteShader")]
        public static 
        void DeleteShader(Int32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Deletes a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteShader")]
        public static 
        void DeleteShader(UInt32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// The sync object to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteSync")]
        public static 
        void DeleteSync(IntPtr sync)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteSync((IntPtr)sync);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTexture(Int32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* textures_ptr = (UInt32*)&textures;
                Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTexture(UInt32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* textures_ptr = (UInt32*)&textures;
                Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTextures(Int32 n, Int32[] textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* textures_ptr = textures)
                {
                    Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTextures(Int32 n, ref Int32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* textures_ptr = &textures)
                {
                    Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        unsafe void DeleteTextures(Int32 n, Int32* textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteTextures((Int32)n, (UInt32*)textures);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTextures(Int32 n, UInt32[] textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* textures_ptr = textures)
                {
                    Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        void DeleteTextures(Int32 n, ref UInt32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* textures_ptr = &textures)
                {
                    Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDeleteTextures")]
        public static 
        unsafe void DeleteTextures(Int32 n, UInt32* textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteTextures((Int32)n, (UInt32*)textures);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedback(Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* ids_ptr = (UInt32*)&ids;
                Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedback(UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* ids_ptr = (UInt32*)&ids;
                Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedbacks(Int32 n, Int32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedbacks(Int32 n, ref Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        unsafe void DeleteTransformFeedbacks(Int32 n, Int32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedbacks(Int32 n, UInt32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        void DeleteTransformFeedbacks(Int32 n, ref UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete transform feedback objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback objects to delete.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of names of transform feedback objects to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteTransformFeedbacks")]
        public static 
        unsafe void DeleteTransformFeedbacks(Int32 n, UInt32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteTransformFeedbacks((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArray(Int32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* arrays_ptr = (UInt32*)&arrays;
                Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArray(UInt32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                UInt32* arrays_ptr = (UInt32*)&arrays;
                Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArrays(Int32 n, Int32[] arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* arrays_ptr = arrays)
                {
                    Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArrays(Int32 n, ref Int32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* arrays_ptr = &arrays)
                {
                    Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        unsafe void DeleteVertexArrays(Int32 n, Int32* arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArrays(Int32 n, UInt32[] arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* arrays_ptr = arrays)
                {
                    Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        void DeleteVertexArrays(Int32 n, ref UInt32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* arrays_ptr = &arrays)
                {
                    Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Delete vertex array objects
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array objects to be deleted.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDeleteVertexArrays")]
        public static 
        unsafe void DeleteVertexArrays(Int32 n, UInt32* arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDeleteVertexArrays((Int32)n, (UInt32*)arrays);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value used for depth buffer comparisons
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthFunc")]
        public static 
        void DepthFunc(OpenTK.Graphics.ES30.All func)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDepthFunc((OpenTK.Graphics.ES30.DepthFunction)func);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value used for depth buffer comparisons
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthFunc")]
        public static 
        void DepthFunc(OpenTK.Graphics.ES30.DepthFunction func)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDepthFunc((OpenTK.Graphics.ES30.DepthFunction)func);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable or disable writing into the depth buffer
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthMask")]
        public static 
        void DepthMask(bool flag)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDepthMask((bool)flag);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify mapping of depth values from normalized device coordinates to window coordinates
        /// </summary>
        /// <param name="nearVal">
        /// <para>
        /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDepthRangef")]
        public static 
        void DepthRange(Single n, Single f)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDepthRangef((Single)n, (Single)f);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Detaches a shader object from a program object to which it is attached
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object from which to detach the shader object.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be detached.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDetachShader")]
        public static 
        void DetachShader(Int32 program, Int32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDetachShader((UInt32)program, (UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Detaches a shader object from a program object to which it is attached
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object from which to detach the shader object.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be detached.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDetachShader")]
        public static 
        void DetachShader(UInt32 program, UInt32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDetachShader((UInt32)program, (UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisable")]
        public static 
        void Disable(OpenTK.Graphics.ES30.All cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDisable((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisable")]
        public static 
        void Disable(OpenTK.Graphics.ES30.EnableCap cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDisable((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisableVertexAttribArray")]
        public static 
        void DisableVertexAttribArray(Int32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDisableVertexAttribArray((UInt32)index);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDisableVertexAttribArray")]
        public static 
        void DisableVertexAttribArray(UInt32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDisableVertexAttribArray((UInt32)index);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// <para>
        /// Specifies the starting index in the enabled arrays.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawArrays")]
        public static 
        void DrawArrays(OpenTK.Graphics.ES30.All mode, Int32 first, Int32 count)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawArrays((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// <para>
        /// Specifies the starting index in the enabled arrays.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawArrays")]
        public static 
        void DrawArrays(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 first, Int32 count)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawArrays((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a range of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// <para>
        /// Specifies the starting index in the enabled arrays.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of indices to be rendered.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawArraysInstanced")]
        public static 
        void DrawArraysInstanced(OpenTK.Graphics.ES30.All mode, Int32 first, Int32 count, Int32 instancecount)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawArraysInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)instancecount);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a range of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// <para>
        /// Specifies the starting index in the enabled arrays.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of indices to be rendered.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawArraysInstanced")]
        public static 
        void DrawArraysInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 first, Int32 count, Int32 instancecount)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawArraysInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)instancecount);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All[] bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* bufs_ptr = bufs)
                {
                    Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.All bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* bufs_ptr = &bufs)
                {
                    Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All* bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode[] bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = bufs)
                {
                    Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.DrawBufferMode bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = &bufs)
                {
                    Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specifies a list of color buffers to be drawn into
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in bufs.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawBuffers")]
        public static 
        unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode* bufs)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawBuffers((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T3)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glDrawElements")]
        public static 
        void DrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T3)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 instancecount)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)instancecount);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
                indices = (T3)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 instancecount)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)instancecount);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Draw multiple instances of a set of elements
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        /// <param name="primcount">
        /// <para>
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawElementsInstanced")]
        public static 
        void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 instancecount)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)instancecount);
                indices = (T3)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T5)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements(OpenTK.Graphics.ES30.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.All mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T5)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T5)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements(OpenTK.Graphics.ES30.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glDrawRangeElements")]
        public static 
        void DrawRangeElements<T5>(OpenTK.Graphics.ES30.PrimitiveType mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try
            {
                Delegates.glDrawRangeElements((OpenTK.Graphics.ES30.PrimitiveType)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                indices = (T5)indices_ptr.Target;
            }
            finally
            {
                indices_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable or disable server-side GL capabilities
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnable")]
        public static 
        void Enable(OpenTK.Graphics.ES30.All cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEnable((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable or disable server-side GL capabilities
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnable")]
        public static 
        void Enable(OpenTK.Graphics.ES30.EnableCap cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEnable((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable or disable a generic vertex attribute array
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnableVertexAttribArray")]
        public static 
        void EnableVertexAttribArray(Int32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEnableVertexAttribArray((UInt32)index);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Enable or disable a generic vertex attribute array
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glEnableVertexAttribArray")]
        public static 
        void EnableVertexAttribArray(UInt32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEnableVertexAttribArray((UInt32)index);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glEndQuery")]
        public static 
        void EndQuery(OpenTK.Graphics.ES30.All target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEndQuery((OpenTK.Graphics.ES30.QueryTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glEndQuery")]
        public static 
        void EndQuery(OpenTK.Graphics.ES30.QueryTarget target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEndQuery((OpenTK.Graphics.ES30.QueryTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glEndTransformFeedback")]
        public static 
        void EndTransformFeedback()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glEndTransformFeedback();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Create a new sync object and insert it into the GL command stream
        /// </summary>
        /// <param name="condition">
        /// <para>
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFenceSync")]
        public static 
        IntPtr FenceSync(OpenTK.Graphics.ES30.All condition, OpenTK.Graphics.ES30.All flags)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glFenceSync((OpenTK.Graphics.ES30.SyncCondition)condition, (OpenTK.Graphics.ES30.WaitSyncFlags)flags);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Create a new sync object and insert it into the GL command stream
        /// </summary>
        /// <param name="condition">
        /// <para>
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFenceSync")]
        public static 
        IntPtr FenceSync(OpenTK.Graphics.ES30.SyncCondition condition, OpenTK.Graphics.ES30.WaitSyncFlags flags)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glFenceSync((OpenTK.Graphics.ES30.SyncCondition)condition, (OpenTK.Graphics.ES30.WaitSyncFlags)flags);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Block until all GL execution is complete
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFinish")]
        public static 
        void Finish()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFinish();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Force execution of GL commands in finite time
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFlush")]
        public static 
        void Flush()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFlush();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the flush operation. target must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static 
        void FlushMappedBufferRange(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFlushMappedBufferRange((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Indicate modifications to a range of a mapped buffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the flush operation. target must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFlushMappedBufferRange")]
        public static 
        void FlushMappedBufferRange(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFlushMappedBufferRange((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer.
        /// </para>
        /// </param>
        /// <param name="renderbuffertarget">
        /// <para>
        /// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        public static 
        void FramebufferRenderbuffer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All renderbuffertarget, Int32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferRenderbuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer.
        /// </para>
        /// </param>
        /// <param name="renderbuffertarget">
        /// <para>
        /// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        public static 
        void FramebufferRenderbuffer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All renderbuffertarget, UInt32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferRenderbuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer.
        /// </para>
        /// </param>
        /// <param name="renderbuffertarget">
        /// <para>
        /// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        public static 
        void FramebufferRenderbuffer(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.RenderbufferTarget renderbuffertarget, Int32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferRenderbuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer.
        /// </para>
        /// </param>
        /// <param name="renderbuffertarget">
        /// <para>
        /// Specifies the renderbuffer target and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferRenderbuffer")]
        public static 
        void FramebufferRenderbuffer(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.RenderbufferTarget renderbuffertarget, UInt32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferRenderbuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        public static 
        void FramebufferTexture2D(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, Int32 texture, Int32 level)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTexture2D((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.TextureTarget2d)textarget, (UInt32)texture, (Int32)level);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        public static 
        void FramebufferTexture2D(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, UInt32 texture, Int32 level)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTexture2D((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.TextureTarget2d)textarget, (UInt32)texture, (Int32)level);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        public static 
        void FramebufferTexture2D(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.TextureTarget2d textarget, Int32 texture, Int32 level)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTexture2D((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.TextureTarget2d)textarget, (UInt32)texture, (Int32)level);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFramebufferTexture2D")]
        public static 
        void FramebufferTexture2D(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.TextureTarget2d textarget, UInt32 texture, Int32 level)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTexture2D((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.TextureTarget2d)textarget, (UInt32)texture, (Int32)level);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the mipmap level of texture to attach.
        /// </para>
        /// </param>
        /// <param name="layer">
        /// <para>
        /// Specifies the layer of texture to attach.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        public static 
        void FramebufferTextureLayer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, Int32 texture, Int32 level, Int32 layer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTextureLayer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the mipmap level of texture to attach.
        /// </para>
        /// </param>
        /// <param name="layer">
        /// <para>
        /// Specifies the layer of texture to attach.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        public static 
        void FramebufferTextureLayer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, UInt32 texture, Int32 level, Int32 layer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTextureLayer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the mipmap level of texture to attach.
        /// </para>
        /// </param>
        /// <param name="layer">
        /// <para>
        /// Specifies the layer of texture to attach.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        public static 
        void FramebufferTextureLayer(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTextureLayer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Attach a single layer of a texture to a framebuffer
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMENT.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the texture object to attach to the framebuffer attachment point named by attachment.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the mipmap level of texture to attach.
        /// </para>
        /// </param>
        /// <param name="layer">
        /// <para>
        /// Specifies the layer of texture to attach.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glFramebufferTextureLayer")]
        public static 
        void FramebufferTextureLayer(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFramebufferTextureLayer((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define front- and back-facing polygons
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFrontFace")]
        public static 
        void FrontFace(OpenTK.Graphics.ES30.All mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFrontFace((OpenTK.Graphics.ES30.FrontFaceDirection)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define front- and back-facing polygons
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glFrontFace")]
        public static 
        void FrontFace(OpenTK.Graphics.ES30.FrontFaceDirection mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glFrontFace((OpenTK.Graphics.ES30.FrontFaceDirection)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        Int32 GenBuffer()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* buffers_ptr = &retval;
                Delegates.glGenBuffers((Int32)n, (UInt32*)buffers_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        void GenBuffers(Int32 n, [OutAttribute] Int32[] buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* buffers_ptr = buffers)
                {
                    Delegates.glGenBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        void GenBuffers(Int32 n, [OutAttribute] out Int32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* buffers_ptr = &buffers)
                {
                    Delegates.glGenBuffers((Int32)n, (UInt32*)buffers_ptr);
                    buffers = *buffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        unsafe void GenBuffers(Int32 n, [OutAttribute] Int32* buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenBuffers((Int32)n, (UInt32*)buffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        void GenBuffers(Int32 n, [OutAttribute] UInt32[] buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* buffers_ptr = buffers)
                {
                    Delegates.glGenBuffers((Int32)n, (UInt32*)buffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        void GenBuffers(Int32 n, [OutAttribute] out UInt32 buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* buffers_ptr = &buffers)
                {
                    Delegates.glGenBuffers((Int32)n, (UInt32*)buffers_ptr);
                    buffers = *buffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate buffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffer object names to be generated.
        /// </para>
        /// </param>
        /// <param name="buffers">
        /// <para>
        /// Specifies an array in which the generated buffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenBuffers")]
        public static 
        unsafe void GenBuffers(Int32 n, [OutAttribute] UInt32* buffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenBuffers((Int32)n, (UInt32*)buffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate mipmaps for a specified texture target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture whose mimaps to generate is bound. target must be GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenerateMipmap")]
        public static 
        void GenerateMipmap(OpenTK.Graphics.ES30.All target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenerateMipmap((OpenTK.Graphics.ES30.TextureTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate mipmaps for a specified texture target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture whose mimaps to generate is bound. target must be GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenerateMipmap")]
        public static 
        void GenerateMipmap(OpenTK.Graphics.ES30.TextureTarget target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenerateMipmap((OpenTK.Graphics.ES30.TextureTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        Int32 GenFramebuffer()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* framebuffers_ptr = &retval;
                Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        void GenFramebuffers(Int32 n, [OutAttribute] Int32[] framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* framebuffers_ptr = framebuffers)
                {
                    Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        void GenFramebuffers(Int32 n, [OutAttribute] out Int32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* framebuffers_ptr = &framebuffers)
                {
                    Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                    framebuffers = *framebuffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        unsafe void GenFramebuffers(Int32 n, [OutAttribute] Int32* framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        void GenFramebuffers(Int32 n, [OutAttribute] UInt32[] framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* framebuffers_ptr = framebuffers)
                {
                    Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        void GenFramebuffers(Int32 n, [OutAttribute] out UInt32 framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* framebuffers_ptr = &framebuffers)
                {
                    Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers_ptr);
                    framebuffers = *framebuffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate framebuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of framebuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenFramebuffers")]
        public static 
        unsafe void GenFramebuffers(Int32 n, [OutAttribute] UInt32* framebuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenFramebuffers((Int32)n, (UInt32*)framebuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        Int32 GenQuery()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* ids_ptr = &retval;
                Delegates.glGenQueries((Int32)n, (UInt32*)ids_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        void GenQueries(Int32 n, [OutAttribute] Int32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glGenQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        void GenQueries(Int32 n, [OutAttribute] out Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glGenQueries((Int32)n, (UInt32*)ids_ptr);
                    ids = *ids_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        unsafe void GenQueries(Int32 n, [OutAttribute] Int32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenQueries((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        void GenQueries(Int32 n, [OutAttribute] UInt32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glGenQueries((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        void GenQueries(Int32 n, [OutAttribute] out UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glGenQueries((Int32)n, (UInt32*)ids_ptr);
                    ids = *ids_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate query object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of query object names to be generated.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array in which the generated query object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenQueries")]
        public static 
        unsafe void GenQueries(Int32 n, [OutAttribute] UInt32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenQueries((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        Int32 GenRenderbuffer()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* renderbuffers_ptr = &retval;
                Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        void GenRenderbuffers(Int32 n, [OutAttribute] Int32[] renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* renderbuffers_ptr = renderbuffers)
                {
                    Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        void GenRenderbuffers(Int32 n, [OutAttribute] out Int32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* renderbuffers_ptr = &renderbuffers)
                {
                    Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                    renderbuffers = *renderbuffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        unsafe void GenRenderbuffers(Int32 n, [OutAttribute] Int32* renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        void GenRenderbuffers(Int32 n, [OutAttribute] UInt32[] renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* renderbuffers_ptr = renderbuffers)
                {
                    Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        void GenRenderbuffers(Int32 n, [OutAttribute] out UInt32 renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* renderbuffers_ptr = &renderbuffers)
                {
                    Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers_ptr);
                    renderbuffers = *renderbuffers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate renderbuffer object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of renderbuffer object names to generate.
        /// </para>
        /// </param>
        /// <param name="renderbuffers">
        /// <para>
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenRenderbuffers")]
        public static 
        unsafe void GenRenderbuffers(Int32 n, [OutAttribute] UInt32* renderbuffers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenRenderbuffers((Int32)n, (UInt32*)renderbuffers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        Int32 GenSampler()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 count = 1;
                Int32 retval;
                Int32* samplers_ptr = &retval;
                Delegates.glGenSamplers((Int32)count, (UInt32*)samplers_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        void GenSamplers(Int32 count, [OutAttribute] Int32[] samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* samplers_ptr = samplers)
                {
                    Delegates.glGenSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        void GenSamplers(Int32 count, [OutAttribute] out Int32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* samplers_ptr = &samplers)
                {
                    Delegates.glGenSamplers((Int32)count, (UInt32*)samplers_ptr);
                    samplers = *samplers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        unsafe void GenSamplers(Int32 count, [OutAttribute] Int32* samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenSamplers((Int32)count, (UInt32*)samplers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        void GenSamplers(Int32 count, [OutAttribute] UInt32[] samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* samplers_ptr = samplers)
                {
                    Delegates.glGenSamplers((Int32)count, (UInt32*)samplers_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        void GenSamplers(Int32 count, [OutAttribute] out UInt32 samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* samplers_ptr = &samplers)
                {
                    Delegates.glGenSamplers((Int32)count, (UInt32*)samplers_ptr);
                    samplers = *samplers_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate sampler object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of sampler object names to generate.
        /// </para>
        /// </param>
        /// <param name="samplers">
        /// <para>
        /// Specifies an array in which the generated sampler object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenSamplers")]
        public static 
        unsafe void GenSamplers(Int32 count, [OutAttribute] UInt32* samplers)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenSamplers((Int32)count, (UInt32*)samplers);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        Int32 GenTexture()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* textures_ptr = &retval;
                Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        void GenTextures(Int32 n, [OutAttribute] Int32[] textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* textures_ptr = textures)
                {
                    Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        void GenTextures(Int32 n, [OutAttribute] out Int32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* textures_ptr = &textures)
                {
                    Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                    textures = *textures_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        unsafe void GenTextures(Int32 n, [OutAttribute] Int32* textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenTextures((Int32)n, (UInt32*)textures);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        void GenTextures(Int32 n, [OutAttribute] UInt32[] textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* textures_ptr = textures)
                {
                    Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        void GenTextures(Int32 n, [OutAttribute] out UInt32 textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* textures_ptr = &textures)
                {
                    Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                    textures = *textures_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGenTextures")]
        public static 
        unsafe void GenTextures(Int32 n, [OutAttribute] UInt32* textures)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenTextures((Int32)n, (UInt32*)textures);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        Int32 GenTransformFeedback()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* ids_ptr = &retval;
                Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        void GenTransformFeedbacks(Int32 n, [OutAttribute] Int32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = ids)
                {
                    Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        void GenTransformFeedbacks(Int32 n, [OutAttribute] out Int32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* ids_ptr = &ids)
                {
                    Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                    ids = *ids_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        unsafe void GenTransformFeedbacks(Int32 n, [OutAttribute] Int32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        void GenTransformFeedbacks(Int32 n, [OutAttribute] UInt32[] ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = ids)
                {
                    Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        void GenTransformFeedbacks(Int32 n, [OutAttribute] out UInt32 ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* ids_ptr = &ids)
                {
                    Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids_ptr);
                    ids = *ids_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Reserve transform feedback object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of transform feedback object names to reserve.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// Specifies an array of into which the reserved names will be written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenTransformFeedbacks")]
        public static 
        unsafe void GenTransformFeedbacks(Int32 n, [OutAttribute] UInt32* ids)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenTransformFeedbacks((Int32)n, (UInt32*)ids);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        Int32 GenVertexArray()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                const Int32 n = 1;
                Int32 retval;
                Int32* arrays_ptr = &retval;
                Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        void GenVertexArrays(Int32 n, [OutAttribute] Int32[] arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* arrays_ptr = arrays)
                {
                    Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        void GenVertexArrays(Int32 n, [OutAttribute] out Int32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* arrays_ptr = &arrays)
                {
                    Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                    arrays = *arrays_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        unsafe void GenVertexArrays(Int32 n, [OutAttribute] Int32* arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        void GenVertexArrays(Int32 n, [OutAttribute] UInt32[] arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* arrays_ptr = arrays)
                {
                    Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        void GenVertexArrays(Int32 n, [OutAttribute] out UInt32 arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* arrays_ptr = &arrays)
                {
                    Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays_ptr);
                    arrays = *arrays_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Generate vertex array object names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of vertex array object names to generate.
        /// </para>
        /// </param>
        /// <param name="arrays">
        /// <para>
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGenVertexArrays")]
        public static 
        unsafe void GenVertexArrays(Int32 n, [OutAttribute] UInt32* arrays)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGenVertexArrays((Int32)n, (UInt32*)arrays);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.ActiveAttribType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.ActiveAttribType* type_ptr = &type)
                {
                    Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveAttribType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveAttribType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        unsafe void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.ActiveAttribType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveAttribType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        unsafe void GetActiveAttrib(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveAttribType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.ActiveAttribType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.ActiveAttribType* type_ptr = &type)
                {
                    Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveAttribType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveAttribType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        unsafe void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.ActiveAttribType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveAttribType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active attribute variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the attribute variable.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveAttrib")]
        public static 
        unsafe void GetActiveAttrib(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveAttrib((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveAttribType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.ActiveUniformType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.ActiveUniformType* type_ptr = &type)
                {
                    Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveUniformType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveUniformType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        unsafe void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.ActiveUniformType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveUniformType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        unsafe void GetActiveUniform(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveUniformType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.ActiveUniformType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.ActiveUniformType* type_ptr = &type)
                {
                    Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveUniformType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.ActiveUniformType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        unsafe void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.ActiveUniformType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveUniformType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns information about an active uniform variable for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing the name of the uniform variable.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetActiveUniform")]
        public static 
        unsafe void GetActiveUniform(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniform((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.ActiveUniformType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        unsafe void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        unsafe void GetActiveUniformBlock(Int32 program, Int32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        unsafe void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.ActiveUniformBlockParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query information about an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable to receive the result of the query.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockiv")]
        public static 
        unsafe void GetActiveUniformBlock(UInt32 program, UInt32 uniformBlockIndex, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockiv((UInt32)program, (UInt32)uniformBlockIndex, (OpenTK.Graphics.ES30.ActiveUniformBlockParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        public static 
        void GetActiveUniformBlockName(Int32 program, Int32 uniformBlockIndex, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetActiveUniformBlockName((UInt32)program, (UInt32)uniformBlockIndex, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)uniformBlockName);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        public static 
        unsafe void GetActiveUniformBlockName(Int32 program, Int32 uniformBlockIndex, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockName((UInt32)program, (UInt32)uniformBlockIndex, (Int32)bufSize, (Int32*)length, (StringBuilder)uniformBlockName);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        public static 
        void GetActiveUniformBlockName(UInt32 program, UInt32 uniformBlockIndex, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetActiveUniformBlockName((UInt32)program, (UInt32)uniformBlockIndex, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)uniformBlockName);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the name of an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// Specifies the index of the uniform block within program.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformBlockName")]
        public static 
        unsafe void GetActiveUniformBlockName(UInt32 program, UInt32 uniformBlockIndex, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformBlockName((UInt32)program, (UInt32)uniformBlockIndex, (Int32)bufSize, (Int32*)length, (StringBuilder)uniformBlockName);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(Int32 program, Int32 uniformCount, Int32[] uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = uniformIndices)
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(Int32 program, Int32 uniformCount, Int32[] uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = uniformIndices)
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(Int32 program, Int32 uniformCount, ref Int32 uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = &uniformIndices)
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(Int32 program, Int32 uniformCount, ref Int32 uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = &uniformIndices)
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        unsafe void GetActiveUniforms(Int32 program, Int32 uniformCount, Int32* uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        unsafe void GetActiveUniforms(Int32 program, Int32 uniformCount, Int32* uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(UInt32 program, Int32 uniformCount, UInt32[] uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = uniformIndices)
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(UInt32 program, Int32 uniformCount, UInt32[] uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = uniformIndices)
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(UInt32 program, Int32 uniformCount, ref UInt32 uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = &uniformIndices)
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        void GetActiveUniforms(UInt32 program, Int32 uniformCount, ref UInt32 uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = &uniformIndices)
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices_ptr, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        unsafe void GetActiveUniforms(UInt32 program, Int32 uniformCount, UInt32* uniformIndices, OpenTK.Graphics.ES30.ActiveUniformParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns information about several active uniform variables for the specified program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname should be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the property of each uniform in uniformIndices that should be written into the corresponding element of params.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetActiveUniformsiv")]
        public static 
        unsafe void GetActiveUniforms(UInt32 program, Int32 uniformCount, UInt32* uniformIndices, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetActiveUniformsiv((UInt32)program, (Int32)uniformCount, (UInt32*)uniformIndices, (OpenTK.Graphics.ES30.ActiveUniformParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] Int32[] shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* count_ptr = &count)
                fixed (Int32* shaders_ptr = shaders)
                {
                    Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)shaders_ptr);
                    count = *count_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] out Int32 shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* count_ptr = &count)
                fixed (Int32* shaders_ptr = &shaders)
                {
                    Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)shaders_ptr);
                    count = *count_ptr;
                    shaders = *shaders_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        unsafe void GetAttachedShaders(Int32 program, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] Int32* shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count, (UInt32*)shaders);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] UInt32[] shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* count_ptr = &count)
                fixed (UInt32* shaders_ptr = shaders)
                {
                    Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)shaders_ptr);
                    count = *count_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] out UInt32 shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* count_ptr = &count)
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)shaders_ptr);
                    count = *count_ptr;
                    shaders = *shaders_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the handles of the shader objects attached to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttachedShaders")]
        public static 
        unsafe void GetAttachedShaders(UInt32 program, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] UInt32* shaders)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetAttachedShaders((UInt32)program, (Int32)maxCount, (Int32*)count, (UInt32*)shaders);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the location of an attribute variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttribLocation")]
        public static 
        Int32 GetAttribLocation(Int32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetAttribLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the location of an attribute variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetAttribLocation")]
        public static 
        Int32 GetAttribLocation(UInt32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetAttribLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        bool GetBoolean(OpenTK.Graphics.ES30.All pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                bool retval;
                bool* data_ptr = &retval;
                Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        bool GetBoolean(OpenTK.Graphics.ES30.GetPName pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                bool retval;
                bool* data_ptr = &retval;
                Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        void GetBoolean(OpenTK.Graphics.ES30.All pname, [OutAttribute] bool[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (bool* data_ptr = data)
                {
                    Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        void GetBoolean(OpenTK.Graphics.ES30.All pname, [OutAttribute] out bool data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (bool* data_ptr = &data)
                {
                    Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        unsafe void GetBoolean(OpenTK.Graphics.ES30.All pname, [OutAttribute] bool* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        void GetBoolean(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] bool[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (bool* data_ptr = data)
                {
                    Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        void GetBoolean(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] out bool data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (bool* data_ptr = &data)
                {
                    Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBooleanv")]
        public static 
        unsafe void GetBoolean(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] bool* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBooleanv((OpenTK.Graphics.ES30.GetPName)pname, (bool*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* @params_ptr = @params)
                {
                    Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int64 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* @params_ptr = &@params)
                {
                    Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        unsafe void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] Int64[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* @params_ptr = @params)
                {
                    Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] out Int64 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* @params_ptr = &@params)
                {
                    Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferParameteri64v")]
        public static 
        unsafe void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] Int64* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferParameteri64v((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int64*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        unsafe void GetBufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return parameters of a buffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the requested parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetBufferParameteriv")]
        public static 
        unsafe void GetBufferParameter(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferParameteriv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,,] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T2 @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                @params = (T2)@params_ptr.Target;
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [OutAttribute] IntPtr @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[,] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[,,] @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return the pointer to a mapped buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetBufferPointerv")]
        public static 
        void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] ref T2 @params)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetBufferPointerv((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                @params = (T2)@params_ptr.Target;
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All[] sources, [OutAttribute] OpenTK.Graphics.ES30.All[] types, [OutAttribute] Int32[] ids, [OutAttribute] OpenTK.Graphics.ES30.All[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* sources_ptr = sources)
                fixed (OpenTK.Graphics.ES30.All* types_ptr = types)
                fixed (Int32* ids_ptr = ids)
                fixed (OpenTK.Graphics.ES30.All* severities_ptr = severities)
                fixed (Int32* lengths_ptr = lengths)
                {
                    return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.All sources, [OutAttribute] out OpenTK.Graphics.ES30.All types, [OutAttribute] out Int32 ids, [OutAttribute] out OpenTK.Graphics.ES30.All severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* sources_ptr = &sources)
                fixed (OpenTK.Graphics.ES30.All* types_ptr = &types)
                fixed (Int32* ids_ptr = &ids)
                fixed (OpenTK.Graphics.ES30.All* severities_ptr = &severities)
                fixed (Int32* lengths_ptr = &lengths)
                {
                    Int32 retval = Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    sources = *sources_ptr;
                    types = *types_ptr;
                    ids = *ids_ptr;
                    severities = *severities_ptr;
                    lengths = *lengths_ptr;
                    return retval;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All* sources, [OutAttribute] OpenTK.Graphics.ES30.All* types, [OutAttribute] Int32* ids, [OutAttribute] OpenTK.Graphics.ES30.All* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal[] sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType[] types, [OutAttribute] Int32[] ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = sources)
                fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = types)
                fixed (Int32* ids_ptr = ids)
                fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = severities)
                fixed (Int32* lengths_ptr = lengths)
                {
                    return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.DebugSourceExternal sources, [OutAttribute] out OpenTK.Graphics.ES30.DebugType types, [OutAttribute] out Int32 ids, [OutAttribute] out OpenTK.Graphics.ES30.DebugSeverity severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = &sources)
                fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = &types)
                fixed (Int32* ids_ptr = &ids)
                fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = &severities)
                fixed (Int32* lengths_ptr = &lengths)
                {
                    Int32 retval = Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    sources = *sources_ptr;
                    types = *types_ptr;
                    ids = *ids_ptr;
                    severities = *severities_ptr;
                    lengths = *lengths_ptr;
                    return retval;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal* sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType* types, [OutAttribute] Int32* ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All[] sources, [OutAttribute] OpenTK.Graphics.ES30.All[] types, [OutAttribute] UInt32[] ids, [OutAttribute] OpenTK.Graphics.ES30.All[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* sources_ptr = sources)
                fixed (OpenTK.Graphics.ES30.All* types_ptr = types)
                fixed (UInt32* ids_ptr = ids)
                fixed (OpenTK.Graphics.ES30.All* severities_ptr = severities)
                fixed (Int32* lengths_ptr = lengths)
                {
                    return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.All sources, [OutAttribute] out OpenTK.Graphics.ES30.All types, [OutAttribute] out UInt32 ids, [OutAttribute] out OpenTK.Graphics.ES30.All severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* sources_ptr = &sources)
                fixed (OpenTK.Graphics.ES30.All* types_ptr = &types)
                fixed (UInt32* ids_ptr = &ids)
                fixed (OpenTK.Graphics.ES30.All* severities_ptr = &severities)
                fixed (Int32* lengths_ptr = &lengths)
                {
                    Int32 retval = Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    sources = *sources_ptr;
                    types = *types_ptr;
                    ids = *ids_ptr;
                    severities = *severities_ptr;
                    lengths = *lengths_ptr;
                    return retval;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All* sources, [OutAttribute] OpenTK.Graphics.ES30.All* types, [OutAttribute] UInt32* ids, [OutAttribute] OpenTK.Graphics.ES30.All* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal[] sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType[] types, [OutAttribute] UInt32[] ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = sources)
                fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = types)
                fixed (UInt32* ids_ptr = ids)
                fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = severities)
                fixed (Int32* lengths_ptr = lengths)
                {
                    return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.DebugSourceExternal sources, [OutAttribute] out OpenTK.Graphics.ES30.DebugType types, [OutAttribute] out UInt32 ids, [OutAttribute] out OpenTK.Graphics.ES30.DebugSeverity severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = &sources)
                fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = &types)
                fixed (UInt32* ids_ptr = &ids)
                fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = &severities)
                fixed (Int32* lengths_ptr = &lengths)
                {
                    Int32 retval = Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    sources = *sources_ptr;
                    types = *types_ptr;
                    ids = *ids_ptr;
                    severities = *severities_ptr;
                    lengths = *lengths_ptr;
                    return retval;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve messages from the debug message log
        /// </summary>
        /// <param name="count">
        /// <para>
        /// The number of debug messages to retrieve from the log.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The size of the buffer whose address is given by messageLog.
        /// </para>
        /// </param>
        /// <param name="sources">
        /// <para>
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="ids">
        /// <para>
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="severities">
        /// <para>
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </para>
        /// </param>
        /// <param name="lengths">
        /// <para>
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </para>
        /// </param>
        /// <param name="messageLog">
        /// <para>
        /// The address of an array of characters that will receive the messages.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLog")]
        public static 
        unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal* sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType* types, [OutAttribute] UInt32* ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetDebugMessageLog((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return error information
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetError")]
        public static 
        OpenTK.Graphics.ES30.ErrorCode GetError()
        {
            return Delegates.glGetError();
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        Single GetFloat(OpenTK.Graphics.ES30.All pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Single retval;
                Single* data_ptr = &retval;
                Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        Single GetFloat(OpenTK.Graphics.ES30.GetPName pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Single retval;
                Single* data_ptr = &retval;
                Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        void GetFloat(OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* data_ptr = data)
                {
                    Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        void GetFloat(OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* data_ptr = &data)
                {
                    Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        unsafe void GetFloat(OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        void GetFloat(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Single[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* data_ptr = data)
                {
                    Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        void GetFloat(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] out Single data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* data_ptr = &data)
                {
                    Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFloatv")]
        public static 
        unsafe void GetFloat(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Single* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetFloatv((OpenTK.Graphics.ES30.GetPName)pname, (Single*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the bindings of color numbers to user-defined varying out variables
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the program containing varying out variable whose binding to query
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the user-defined varying out variable whose binding to query
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetFragDataLocation")]
        public static 
        Int32 GetFragDataLocation(Int32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetFragDataLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the bindings of color numbers to user-defined varying out variables
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the program containing varying out variable whose binding to query
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the user-defined varying out variable whose binding to query
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetFragDataLocation")]
        public static 
        Int32 GetFragDataLocation(UInt32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetFragDataLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        unsafe void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.FramebufferParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.FramebufferParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about attachments of a bound framebuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation.
        /// </para>
        /// </param>
        /// <param name="attachment">
        /// <para>
        /// Specifies the attachment within target
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter of attachment to query.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable receive the value of pname for attachment.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetFramebufferAttachmentParameteriv")]
        public static 
        unsafe void GetFramebufferAttachmentParameter(OpenTK.Graphics.ES30.FramebufferTarget target, OpenTK.Graphics.ES30.FramebufferAttachment attachment, OpenTK.Graphics.ES30.FramebufferParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetFramebufferAttachmentParameteriv((OpenTK.Graphics.ES30.FramebufferTarget)target, (OpenTK.Graphics.ES30.FramebufferAttachment)attachment, (OpenTK.Graphics.ES30.FramebufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64i_v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64i_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        Int64 GetInteger64(OpenTK.Graphics.ES30.All pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Int64 retval;
                Int64* data_ptr = &retval;
                Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        Int64 GetInteger64(OpenTK.Graphics.ES30.GetPName pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Int64 retval;
                Int64* data_ptr = &retval;
                Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int64[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = data)
                {
                    Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] out Int64 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int64* data_ptr = &data)
                {
                    Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInteger64v")]
        public static 
        unsafe void GetInteger64(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int64* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInteger64v((OpenTK.Graphics.ES30.GetPName)pname, (Int64*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetIntegeri_v")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegeri_v((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        Int32 GetInteger(OpenTK.Graphics.ES30.All pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Int32 retval;
                Int32* data_ptr = &retval;
                Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        Int32 GetInteger(OpenTK.Graphics.ES30.GetPName pname)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                Int32 retval;
                Int32* data_ptr = &retval;
                Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                return retval;
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int32[] data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = data)
                {
                    Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        void GetInteger(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] out Int32 data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* data_ptr = &data)
                {
                    Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data_ptr);
                    data = *data_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetIntegerv")]
        public static 
        unsafe void GetInteger(OpenTK.Graphics.ES30.GetPName pname, [OutAttribute] Int32* data)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetIntegerv((OpenTK.Graphics.ES30.GetPName)pname, (Int32*)data);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        void GetInternalformat(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All internalformat, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        void GetInternalformat(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All internalformat, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        unsafe void GetInternalformat(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All internalformat, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        void GetInternalformat(OpenTK.Graphics.ES30.ImageTarget target, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, OpenTK.Graphics.ES30.InternalFormatParameter pname, Int32 bufSize, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        void GetInternalformat(OpenTK.Graphics.ES30.ImageTarget target, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, OpenTK.Graphics.ES30.InternalFormatParameter pname, Int32 bufSize, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about implementation-dependent support for internal formats
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format about which to retrieve information.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the type of information to query.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of basic machine units that may be written to params by the function.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetInternalformativ")]
        public static 
        unsafe void GetInternalformat(OpenTK.Graphics.ES30.ImageTarget target, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, OpenTK.Graphics.ES30.InternalFormatParameter pname, Int32 bufSize, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetInternalformativ((OpenTK.Graphics.ES30.ImageTarget)target, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (OpenTK.Graphics.ES30.InternalFormatParameter)pname, (Int32)bufSize, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        unsafe void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabel")]
        public static 
        unsafe void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glGetObjectPtrLabel((IntPtr)ptr, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetObjectPtrLabel((IntPtr)ptr, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        unsafe void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetObjectPtrLabel((IntPtr)ptr, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        ptr = (T0)ptr_ptr.Target;
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        ptr = (T0)ptr_ptr.Target;
                        length = *length_ptr;
                    }
                    finally
                    {
                        ptr_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Retrieve the label of a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// The name of the sync object whose label to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The length of the buffer whose address is in label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable to receive the length of the object label.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string that will receive the object label.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabel")]
        public static 
        unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glGetObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                ptr = (T0)ptr_ptr.Target;
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer(OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[,] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[,,] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T1 @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                @params = (T1)@params_ptr.Target;
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer(OpenTK.Graphics.ES30.GetPointervPName pname, [OutAttribute] IntPtr @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.GetPointervPName pname, [InAttribute, OutAttribute] T1[] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.GetPointervPName pname, [InAttribute, OutAttribute] T1[,] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.GetPointervPName pname, [InAttribute, OutAttribute] T1[,,] @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointerv")]
        public static 
        void GetPointer<T1>(OpenTK.Graphics.ES30.GetPointervPName pname, [InAttribute, OutAttribute] ref T1 @params)
            where T1 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
            try
            {
                Delegates.glGetPointerv((OpenTK.Graphics.ES30.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                @params = (T1)@params_ptr.Target;
            }
            finally
            {
                @params_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [OutAttribute] IntPtr binary)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                    length = *length_ptr;
                    binaryFormat = *binaryFormat_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                        binary = (T4)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [OutAttribute] IntPtr binary)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                binary = (T4)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [OutAttribute] IntPtr binary)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                    length = *length_ptr;
                    binaryFormat = *binaryFormat_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                        binary = (T4)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [OutAttribute] IntPtr binary)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a binary representation of a program object's compiled and linked executable source
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given by binary.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array into which the GL will return program's binary representation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetProgramBinary")]
        public static 
        unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glGetProgramBinary((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                binary = (T4)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        public static 
        void GetProgramInfoLog(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetProgramInfoLog((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        public static 
        unsafe void GetProgramInfoLog(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramInfoLog((UInt32)program, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        public static 
        void GetProgramInfoLog(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetProgramInfoLog((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramInfoLog")]
        public static 
        unsafe void GetProgramInfoLog(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramInfoLog((UInt32)program, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(Int32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(Int32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        unsafe void GetProgram(Int32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(Int32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(Int32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        unsafe void GetProgram(Int32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(UInt32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(UInt32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        unsafe void GetProgram(UInt32 program, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(UInt32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        void GetProgram(UInt32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetProgramiv")]
        public static 
        unsafe void GetProgram(UInt32 program, OpenTK.Graphics.ES30.GetProgramParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetProgramiv((UInt32)program, (OpenTK.Graphics.ES30.GetProgramParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        unsafe void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryiv")]
        public static 
        unsafe void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryiv((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = @params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out UInt32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = @params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out UInt32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = &@params)
                {
                    Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return parameters of a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies the name of a query object.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetQueryObjectuiv")]
        public static 
        unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetQueryObjectuiv((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        void GetRenderbufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        void GetRenderbufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        unsafe void GetRenderbufferParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        void GetRenderbufferParameter(OpenTK.Graphics.ES30.RenderbufferTarget target, OpenTK.Graphics.ES30.RenderbufferParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        void GetRenderbufferParameter(OpenTK.Graphics.ES30.RenderbufferTarget target, OpenTK.Graphics.ES30.RenderbufferParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve information about a bound renderbuffer object
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target of the query operation. target must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the renderbuffer bound to target.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Specifies the address of an array to receive the value of the queried parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetRenderbufferParameteriv")]
        public static 
        unsafe void GetRenderbufferParameter(OpenTK.Graphics.ES30.RenderbufferTarget target, OpenTK.Graphics.ES30.RenderbufferParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetRenderbufferParameteriv((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameterfv")]
        public static 
        unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        unsafe void GetSamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return sampler parameter values
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the sampler parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSamplerParameteriv")]
        public static 
        unsafe void GetSamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        public static 
        void GetShaderInfoLog(Int32 shader, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetShaderInfoLog((UInt32)shader, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        public static 
        unsafe void GetShaderInfoLog(Int32 shader, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderInfoLog((UInt32)shader, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        public static 
        void GetShaderInfoLog(UInt32 shader, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetShaderInfoLog((UInt32)shader, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the information log for a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used to return the information log.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderInfoLog")]
        public static 
        unsafe void GetShaderInfoLog(UInt32 shader, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderInfoLog((UInt32)shader, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(Int32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(Int32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        unsafe void GetShader(Int32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(Int32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(Int32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        unsafe void GetShader(Int32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(UInt32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(UInt32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        unsafe void GetShader(UInt32 shader, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(UInt32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        void GetShader(UInt32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns a parameter from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested object parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderiv")]
        public static 
        unsafe void GetShader(UInt32 shader, OpenTK.Graphics.ES30.ShaderParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderiv((UInt32)shader, (OpenTK.Graphics.ES30.ShaderParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.All shadertype, OpenTK.Graphics.ES30.All precisiontype, [OutAttribute] Int32[] range, [OutAttribute] Int32[] precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* range_ptr = range)
                fixed (Int32* precision_ptr = precision)
                {
                    Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range_ptr, (Int32*)precision_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.All shadertype, OpenTK.Graphics.ES30.All precisiontype, [OutAttribute] out Int32 range, [OutAttribute] out Int32 precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* range_ptr = &range)
                fixed (Int32* precision_ptr = &precision)
                {
                    Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range_ptr, (Int32*)precision_ptr);
                    range = *range_ptr;
                    precision = *precision_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        unsafe void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.All shadertype, OpenTK.Graphics.ES30.All precisiontype, [OutAttribute] Int32* range, [OutAttribute] Int32* precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range, (Int32*)precision);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.ShaderType shadertype, OpenTK.Graphics.ES30.ShaderPrecision precisiontype, [OutAttribute] Int32[] range, [OutAttribute] Int32[] precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* range_ptr = range)
                fixed (Int32* precision_ptr = precision)
                {
                    Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range_ptr, (Int32*)precision_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.ShaderType shadertype, OpenTK.Graphics.ES30.ShaderPrecision precisiontype, [OutAttribute] out Int32 range, [OutAttribute] out Int32 precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* range_ptr = &range)
                fixed (Int32* precision_ptr = &precision)
                {
                    Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range_ptr, (Int32*)precision_ptr);
                    range = *range_ptr;
                    precision = *precision_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Retrieve the range and precision for numeric formats supported by the shader compiler
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
        /// </para>
        /// </param>
        /// <param name="precisionType">
        /// <para>
        /// Specifies the numeric format whose precision and range to query.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
        /// </para>
        /// </param>
        /// <param name="precision">
        /// <para>
        /// Specifies the address of an integer into which the numeric precision of the implementation is written.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderPrecisionFormat")]
        public static 
        unsafe void GetShaderPrecisionFormat(OpenTK.Graphics.ES30.ShaderType shadertype, OpenTK.Graphics.ES30.ShaderPrecision precisiontype, [OutAttribute] Int32* range, [OutAttribute] Int32* precision)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderPrecisionFormat((OpenTK.Graphics.ES30.ShaderType)shadertype, (OpenTK.Graphics.ES30.ShaderPrecision)precisiontype, (Int32*)range, (Int32*)precision);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used to return the source code string.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        public static 
        void GetShaderSource(Int32 shader, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetShaderSource((UInt32)shader, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)source);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used to return the source code string.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        public static 
        unsafe void GetShaderSource(Int32 shader, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderSource((UInt32)shader, (Int32)bufSize, (Int32*)length, (StringBuilder)source);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used to return the source code string.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        public static 
        void GetShaderSource(UInt32 shader, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glGetShaderSource((UInt32)shader, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)source);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the source code string from a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used to return the source code string.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetShaderSource")]
        public static 
        unsafe void GetShaderSource(UInt32 shader, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetShaderSource((UInt32)shader, (Int32)bufSize, (Int32*)length, (StringBuilder)source);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetString")]
        public static 
        String GetString(OpenTK.Graphics.ES30.All name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetString((OpenTK.Graphics.ES30.StringName)name)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetString")]
        public static 
        String GetString(OpenTK.Graphics.ES30.StringName name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetString((OpenTK.Graphics.ES30.StringName)name)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        public static 
        String GetString(OpenTK.Graphics.ES30.All name, Int32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetStringi((OpenTK.Graphics.ES30.StringNameIndexed)name, (UInt32)index)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        public static 
        String GetString(OpenTK.Graphics.ES30.All name, UInt32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetStringi((OpenTK.Graphics.ES30.StringNameIndexed)name, (UInt32)index)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        public static 
        String GetString(OpenTK.Graphics.ES30.StringNameIndexed name, Int32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetStringi((OpenTK.Graphics.ES30.StringNameIndexed)name, (UInt32)index)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// For glGetStringi, specifies the index of the string to return.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetStringi")]
        public static 
        String GetString(OpenTK.Graphics.ES30.StringNameIndexed name, UInt32 index)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe { return new string((sbyte*)Delegates.glGetStringi((OpenTK.Graphics.ES30.StringNameIndexed)name, (UInt32)index)); }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] Int32[] values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* values_ptr = values)
                {
                    Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* values_ptr = &values)
                {
                    Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    length = *length_ptr;
                    values = *values_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES30.All pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length, (Int32*)values);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] Int32[] values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* values_ptr = values)
                {
                    Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    length = *length_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* values_ptr = &values)
                {
                    Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                    length = *length_ptr;
                    values = *values_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Query the properties of a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose properties to query.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the buffer whose address is given in values.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies the address of an array to receive the values of the queried parameter.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetSynciv")]
        public static 
        unsafe void GetSync(IntPtr sync, OpenTK.Graphics.ES30.SyncParameterName pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* values)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.ES30.SyncParameterName)pname, (Int32)bufSize, (Int32*)length, (Int32*)values);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        unsafe void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameterfv")]
        public static 
        unsafe void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        unsafe void GetTexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetTexParameteriv")]
        public static 
        unsafe void GetTexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.GetTextureParameterName pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.GetTextureParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.TransformFeedbackType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.TransformFeedbackType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.TransformFeedbackType* type_ptr = &type)
                {
                    Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.TransformFeedbackType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        unsafe void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.TransformFeedbackType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        unsafe void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.TransformFeedbackType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.TransformFeedbackType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.All type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.All* type_ptr = &type)
                {
                    Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.TransformFeedbackType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.ES30.TransformFeedbackType type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                fixed (Int32* size_ptr = &size)
                fixed (OpenTK.Graphics.ES30.TransformFeedbackType* type_ptr = &type)
                {
                    Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.ES30.TransformFeedbackType*)type_ptr, (StringBuilder)name);
                    length = *length_ptr;
                    size = *size_ptr;
                    type = *type_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        unsafe void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.All* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.TransformFeedbackType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve information about varying variables selected for transform feedback
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// The index of the varying variable whose information to retrieve.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// The address of a variable that will receive the size of the varying.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The address of a variable that will recieve the type of the varying.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The address of a buffer into which will be written the name of the varying.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetTransformFeedbackVarying")]
        public static 
        unsafe void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.ES30.TransformFeedbackType* type, [OutAttribute] StringBuilder name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetTransformFeedbackVarying((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.ES30.TransformFeedbackType*)type, (StringBuilder)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformBlockIndex")]
        public static 
        Int32 GetUniformBlockIndex(Int32 program, String uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetUniformBlockIndex((UInt32)program, (String)uniformBlockName);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing the uniform block.
        /// </para>
        /// </param>
        /// <param name="uniformBlockName">
        /// <para>
        /// Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformBlockIndex")]
        public static 
        Int32 GetUniformBlockIndex(UInt32 program, String uniformBlockName)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetUniformBlockIndex((UInt32)program, (String)uniformBlockName);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        void GetUniform(Int32 program, Int32 location, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        void GetUniform(Int32 program, Int32 location, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformfv")]
        public static 
        unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformfv((UInt32)program, (Int32)location, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        void GetUniformIndices(Int32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] Int32[] uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = uniformIndices)
                {
                    Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        void GetUniformIndices(Int32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] out Int32 uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* uniformIndices_ptr = &uniformIndices)
                {
                    Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices_ptr);
                    uniformIndices = *uniformIndices_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        unsafe void GetUniformIndices(Int32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] Int32* uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        void GetUniformIndices(UInt32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] UInt32[] uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = uniformIndices)
                {
                    Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        void GetUniformIndices(UInt32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] out UInt32 uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* uniformIndices_ptr = &uniformIndices)
                {
                    Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices_ptr);
                    uniformIndices = *uniformIndices_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Retrieve the index of a named uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformCount">
        /// <para>
        /// Specifies the number of uniforms whose indices to query.
        /// </para>
        /// </param>
        /// <param name="uniformNames">
        /// <para>
        /// Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
        /// </para>
        /// </param>
        /// <param name="uniformIndices">
        /// <para>
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformIndices")]
        public static 
        unsafe void GetUniformIndices(UInt32 program, Int32 uniformCount, String[] uniformNames, [OutAttribute] UInt32* uniformIndices)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformIndices((UInt32)program, (Int32)uniformCount, (String[])uniformNames, (UInt32*)uniformIndices);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        void GetUniform(Int32 program, Int32 location, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        void GetUniform(Int32 program, Int32 location, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformiv")]
        public static 
        unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformiv((UInt32)program, (Int32)location, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the location of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformLocation")]
        public static 
        Int32 GetUniformLocation(Int32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetUniformLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Returns the location of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetUniformLocation")]
        public static 
        Int32 GetUniformLocation(UInt32 program, String name)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glGetUniformLocation((UInt32)program, (String)name);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] UInt32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = @params)
                {
                    Delegates.glGetUniformuiv((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        public static 
        void GetUniform(UInt32 program, Int32 location, [OutAttribute] out UInt32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = &@params)
                {
                    Delegates.glGetUniformuiv((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be queried.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the value of the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetUniformuiv")]
        public static 
        unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute] UInt32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetUniformuiv((UInt32)program, (Int32)location, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] out Single @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribfv")]
        public static 
        unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribfv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        public static 
        void GetVertexAttribI(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribIiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        public static 
        unsafe void GetVertexAttribI(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribIiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        public static 
        void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribIiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIiv")]
        public static 
        unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribIiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIuiv")]
        public static 
        void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out UInt32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribIuiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (UInt32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glGetVertexAttribIuiv")]
        public static 
        unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribIuiv((UInt32)index, (OpenTK.Graphics.ES30.All)pname, (UInt32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] out Int32 @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = &@params)
                {
                    Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params_ptr);
                    @params = *@params_ptr;
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return a generic vertex attribute parameter
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribiv")]
        public static 
        unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.ES30.VertexAttribParameter pname, [OutAttribute] Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribiv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribParameter)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer(Int32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T2)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer(Int32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [OutAttribute] IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T2)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer(UInt32 index, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T2)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer(UInt32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [OutAttribute] IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Return the address of the specified generic vertex attribute pointer
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Returns the pointer value.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glGetVertexAttribPointerv")]
        public static 
        void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.ES30.VertexAttribPointerParameter pname, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glGetVertexAttribPointerv((UInt32)index, (OpenTK.Graphics.ES30.VertexAttribPointerParameter)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T2)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify implementation-specific hints
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glHint")]
        public static 
        void Hint(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glHint((OpenTK.Graphics.ES30.HintTarget)target, (OpenTK.Graphics.ES30.HintMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify implementation-specific hints
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glHint")]
        public static 
        void Hint(OpenTK.Graphics.ES30.HintTarget target, OpenTK.Graphics.ES30.HintMode mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glHint((OpenTK.Graphics.ES30.HintTarget)target, (OpenTK.Graphics.ES30.HintMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        void InvalidateFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All[] attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* attachments_ptr = attachments)
                {
                    Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        void InvalidateFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, ref OpenTK.Graphics.ES30.All attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* attachments_ptr = &attachments)
                {
                    Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        unsafe void InvalidateFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All* attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        void InvalidateFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, OpenTK.Graphics.ES30.FramebufferAttachment[] attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.FramebufferAttachment* attachments_ptr = attachments)
                {
                    Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        void InvalidateFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, ref OpenTK.Graphics.ES30.FramebufferAttachment attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.FramebufferAttachment* attachments_ptr = &attachments)
                {
                    Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateFramebuffer")]
        public static 
        unsafe void InvalidateFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, OpenTK.Graphics.ES30.FramebufferAttachment* attachments)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glInvalidateFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All[] attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* attachments_ptr = attachments)
                {
                    Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, ref OpenTK.Graphics.ES30.All attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.All* attachments_ptr = &attachments)
                {
                    Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        unsafe void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All* attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, OpenTK.Graphics.ES30.FramebufferAttachment[] attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.FramebufferAttachment* attachments_ptr = attachments)
                {
                    Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, ref OpenTK.Graphics.ES30.FramebufferAttachment attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (OpenTK.Graphics.ES30.FramebufferAttachment* attachments_ptr = &attachments)
                {
                    Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments_ptr, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Invalidate the content of a region of some or all of a framebuffer object's attachments
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.
        /// </para>
        /// </param>
        /// <param name="numAttachments">
        /// <para>
        /// The number of entries in the attachments array.
        /// </para>
        /// </param>
        /// <param name="attachments">
        /// <para>
        /// The address of an array identifying the attachments to be invalidated.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The X offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The Y offset of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the region to be invalidated.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the region to be invalidated.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glInvalidateSubFramebuffer")]
        public static 
        unsafe void InvalidateSubFramebuffer(OpenTK.Graphics.ES30.FramebufferTarget target, Int32 numAttachments, OpenTK.Graphics.ES30.FramebufferAttachment* attachments, Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glInvalidateSubFramebuffer((OpenTK.Graphics.ES30.FramebufferTarget)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.FramebufferAttachment*)attachments, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a buffer object
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specifies a value that may be the name of a buffer object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsBuffer")]
        public static 
        bool IsBuffer(Int32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsBuffer((UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a buffer object
        /// </summary>
        /// <param name="buffer">
        /// <para>
        /// Specifies a value that may be the name of a buffer object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsBuffer")]
        public static 
        bool IsBuffer(UInt32 buffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsBuffer((UInt32)buffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Test whether a capability is enabled
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the capability.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsEnabled")]
        public static 
        bool IsEnabled(OpenTK.Graphics.ES30.All cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsEnabled((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Test whether a capability is enabled
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the capability.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsEnabled")]
        public static 
        bool IsEnabled(OpenTK.Graphics.ES30.EnableCap cap)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsEnabled((OpenTK.Graphics.ES30.EnableCap)cap);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a framebuffer object
        /// </summary>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies a value that may be the name of a framebuffer object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsFramebuffer")]
        public static 
        bool IsFramebuffer(Int32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsFramebuffer((UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a framebuffer object
        /// </summary>
        /// <param name="framebuffer">
        /// <para>
        /// Specifies a value that may be the name of a framebuffer object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsFramebuffer")]
        public static 
        bool IsFramebuffer(UInt32 framebuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsFramebuffer((UInt32)framebuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determines if a name corresponds to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies a potential program object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsProgram")]
        public static 
        bool IsProgram(Int32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determines if a name corresponds to a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies a potential program object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsProgram")]
        public static 
        bool IsProgram(UInt32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a query object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsQuery")]
        public static 
        bool IsQuery(Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsQuery((UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a query object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a query object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsQuery")]
        public static 
        bool IsQuery(UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsQuery((UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a renderbuffer object
        /// </summary>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsRenderbuffer")]
        public static 
        bool IsRenderbuffer(Int32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsRenderbuffer((UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a renderbuffer object
        /// </summary>
        /// <param name="renderbuffer">
        /// <para>
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsRenderbuffer")]
        public static 
        bool IsRenderbuffer(UInt32 renderbuffer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsRenderbuffer((UInt32)renderbuffer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a sampler object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a sampler object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSampler")]
        public static 
        bool IsSampler(Int32 sampler)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsSampler((UInt32)sampler);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a sampler object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a sampler object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSampler")]
        public static 
        bool IsSampler(UInt32 sampler)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsSampler((UInt32)sampler);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determines if a name corresponds to a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies a potential shader object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsShader")]
        public static 
        bool IsShader(Int32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determines if a name corresponds to a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies a potential shader object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsShader")]
        public static 
        bool IsShader(UInt32 shader)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsShader((UInt32)shader);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a sync object
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies a value that may be the name of a sync object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsSync")]
        public static 
        bool IsSync(IntPtr sync)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsSync((IntPtr)sync);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies a value that may be the name of a texture.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsTexture")]
        public static 
        bool IsTexture(Int32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsTexture((UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies a value that may be the name of a texture.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glIsTexture")]
        public static 
        bool IsTexture(UInt32 texture)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsTexture((UInt32)texture);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a transform feedback object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a transform feedback object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsTransformFeedback")]
        public static 
        bool IsTransformFeedback(Int32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsTransformFeedback((UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a transform feedback object
        /// </summary>
        /// <param name="id">
        /// <para>
        /// Specifies a value that may be the name of a transform feedback object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsTransformFeedback")]
        public static 
        bool IsTransformFeedback(UInt32 id)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsTransformFeedback((UInt32)id);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a vertex array object
        /// </summary>
        /// <param name="array">
        /// <para>
        /// Specifies a value that may be the name of a vertex array object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsVertexArray")]
        public static 
        bool IsVertexArray(Int32 array)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsVertexArray((UInt32)array);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Determine if a name corresponds to a vertex array object
        /// </summary>
        /// <param name="array">
        /// <para>
        /// Specifies a value that may be the name of a vertex array object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glIsVertexArray")]
        public static 
        bool IsVertexArray(UInt32 array)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glIsVertexArray((UInt32)array);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the width of rasterized lines
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specifies the width of rasterized lines. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLineWidth")]
        public static 
        void LineWidth(Single width)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glLineWidth((Single)width);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Links a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to be linked.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLinkProgram")]
        public static 
        void LinkProgram(Int32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glLinkProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Links a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to be linked.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glLinkProgram")]
        public static 
        void LinkProgram(UInt32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glLinkProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target buffer is bound.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies a the starting offset within the buffer of the range to be mapped.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies a length of the range to be mapped.
        /// </para>
        /// </param>
        /// <param name="access">
        /// <para>
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static 
        IntPtr MapBufferRange(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr length, OpenTK.Graphics.ES30.All access)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glMapBufferRange((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (OpenTK.Graphics.ES30.BufferAccessMask)access);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Map a section of a buffer object's data store
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target buffer is bound.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies a the starting offset within the buffer of the range to be mapped.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies a length of the range to be mapped.
        /// </para>
        /// </param>
        /// <param name="access">
        /// <para>
        /// Specifies a combination of access flags indicating the desired access to the range.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glMapBufferRange")]
        public static 
        IntPtr MapBufferRange(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr length, OpenTK.Graphics.ES30.BufferAccessMask access)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glMapBufferRange((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (OpenTK.Graphics.ES30.BufferAccessMask)access);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object to label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        public static 
        void ObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 length, String label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object to label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        public static 
        void ObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 length, String label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object to label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        public static 
        void ObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 length, String label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a named object identified within a namespace
        /// </summary>
        /// <param name="identifier">
        /// <para>
        /// The namespace from which the name of the object is allocated.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// The name of the object to label.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabel")]
        public static 
        void ObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 length, String label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glObjectLabel((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// A pointer identifying a sync object.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static 
        void ObjectPtrLabel(IntPtr ptr, Int32 length, String label)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glObjectPtrLabel((IntPtr)ptr, (Int32)length, (String)label);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// A pointer identifying a sync object.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static 
        void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 length, String label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// A pointer identifying a sync object.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static 
        void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 length, String label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// A pointer identifying a sync object.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static 
        void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 length, String label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Label a a sync object identified by a pointer
        /// </summary>
        /// <param name="ptr">
        /// <para>
        /// A pointer identifying a sync object.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the label to be used for the object.
        /// </para>
        /// </param>
        /// <param name="label">
        /// <para>
        /// The address of a string containing the label to assign to the object.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabel")]
        public static 
        void ObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 length, String label)
            where T0 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
            try
            {
                Delegates.glObjectPtrLabel((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
                ptr = (T0)ptr_ptr.Target;
            }
            finally
            {
                ptr_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Pause transform feedback operations
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glPauseTransformFeedback")]
        public static 
        void PauseTransformFeedback()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPauseTransformFeedback();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPixelStorei")]
        public static 
        void PixelStore(OpenTK.Graphics.ES30.All pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPixelStorei((OpenTK.Graphics.ES30.PixelStoreParameter)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPixelStorei")]
        public static 
        void PixelStore(OpenTK.Graphics.ES30.PixelStoreParameter pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPixelStorei((OpenTK.Graphics.ES30.PixelStoreParameter)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set the scale and units used to calculate depth values
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="units">
        /// <para>
        /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glPolygonOffset")]
        public static 
        void PolygonOffset(Single factor, Single units)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPolygonOffset((Single)factor, (Single)units);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Pop the active debug group
        /// </summary>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPopDebugGroup")]
        public static 
        void PopDebugGroup()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPopDebugGroup();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,,] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T2 binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T2)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,,] binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Load a program object with a program binary
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object into which to load a program binary.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the binary data in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the number of bytes contained in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramBinary")]
        public static 
        void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T2 binary, Int32 length)
            where T2 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glProgramBinary((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T2)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to modify.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the new value of the parameter specified by pname for program.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        public static 
        void ProgramParameter(Int32 program, OpenTK.Graphics.ES30.All pname, Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to modify.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the new value of the parameter specified by pname for program.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        public static 
        void ProgramParameter(Int32 program, OpenTK.Graphics.ES30.ProgramParameterName pname, Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to modify.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the new value of the parameter specified by pname for program.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        public static 
        void ProgramParameter(UInt32 program, OpenTK.Graphics.ES30.All pname, Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a parameter for a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the name of a program object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the name of the parameter to modify.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the new value of the parameter specified by pname for program.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glProgramParameteri")]
        public static 
        void ProgramParameter(UInt32 program, OpenTK.Graphics.ES30.ProgramParameterName pname, Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Push a named debug group into the command stream
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The identifier of the message.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the message to be sent to the debug output stream.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The a string containing the message to be sent to the debug output stream.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroup")]
        public static 
        void PushDebugGroup(OpenTK.Graphics.ES30.All source, Int32 id, Int32 length, String message)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPushDebugGroup((OpenTK.Graphics.ES30.All)source, (UInt32)id, (Int32)length, (String)message);
            #if DEBUG
            }
            #endif
        }

        /// <summary>
        /// Push a named debug group into the command stream
        /// </summary>
        /// <param name="source">
        /// <para>
        /// The source of the debug message.
        /// </para>
        /// </param>
        /// <param name="id">
        /// <para>
        /// The identifier of the message.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// The length of the message to be sent to the debug output stream.
        /// </para>
        /// </param>
        /// <param name="message">
        /// <para>
        /// The a string containing the message to be sent to the debug output stream.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroup")]
        public static 
        void PushDebugGroup(OpenTK.Graphics.ES30.All source, UInt32 id, Int32 length, String message)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glPushDebugGroup((OpenTK.Graphics.ES30.All)source, (UInt32)id, (Int32)length, (String)message);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Select a color buffer source for pixels
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glReadBuffer")]
        public static 
        void ReadBuffer(OpenTK.Graphics.ES30.All mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glReadBuffer((OpenTK.Graphics.ES30.ReadBufferMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Select a color buffer source for pixels
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glReadBuffer")]
        public static 
        void ReadBuffer(OpenTK.Graphics.ES30.ReadBufferMode mode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glReadBuffer((OpenTK.Graphics.ES30.ReadBufferMode)mode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [OutAttribute] IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T6[] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T6[,] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T6[,,] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T6 pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T6)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [OutAttribute] IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T6[] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T6[,] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T6[,,] pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReadPixels")]
        public static 
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T6 pixels)
            where T6 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T6)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Release resources consumed by the implementation's shader compiler
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glReleaseShaderCompiler")]
        public static 
        void ReleaseShaderCompiler()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glReleaseShaderCompiler();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Establish data storage, format and dimensions of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glRenderbufferStorage")]
        public static 
        void RenderbufferStorage(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glRenderbufferStorage((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Establish data storage, format and dimensions of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glRenderbufferStorage")]
        public static 
        void RenderbufferStorage(OpenTK.Graphics.ES30.RenderbufferTarget target, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glRenderbufferStorage((OpenTK.Graphics.ES30.RenderbufferTarget)target, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="samples">
        /// <para>
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glRenderbufferStorageMultisample")]
        public static 
        void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glRenderbufferStorageMultisample((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
        /// </para>
        /// </param>
        /// <param name="samples">
        /// <para>
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the renderbuffer, in pixels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glRenderbufferStorageMultisample")]
        public static 
        void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glRenderbufferStorageMultisample((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Resume transform feedback operations
        /// </summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glResumeTransformFeedback")]
        public static 
        void ResumeTransformFeedback()
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glResumeTransformFeedback();
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify multisample coverage parameters
        /// </summary>
        /// <param name="value">
        /// <para>
        /// Specify a single floating-point sample coverage value. The value is clamped to the range [0 ,1]. The initial value is 1.0.
        /// </para>
        /// </param>
        /// <param name="invert">
        /// <para>
        /// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glSampleCoverage")]
        public static 
        void SampleCoverage(Single value, bool invert)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSampleCoverage((Single)value, (bool)invert);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterf((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterf((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterf((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterf")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterf((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Single[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* param_ptr = param)
                {
                    Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Single* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* param_ptr = param)
                {
                    Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Single[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* param_ptr = param)
                {
                    Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Single* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* param_ptr = param)
                {
                    Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameterfv")]
        public static 
        unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Single* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameterfv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Single*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteri((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteri((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteri((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteri")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteri((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Int32[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* param_ptr = param)
                {
                    Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.All pname, Int32* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* param_ptr = param)
                {
                    Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        unsafe void SamplerParameter(Int32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Int32[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* param_ptr = param)
                {
                    Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.All pname, Int32* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32[] param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* param_ptr = param)
                {
                    Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Set sampler parameters
        /// </summary>
        /// <param name="sampler">
        /// <para>
        /// Specifies the sampler object whose parameter to modify.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glSamplerParameteriv")]
        public static 
        unsafe void SamplerParameter(UInt32 sampler, OpenTK.Graphics.ES30.SamplerParameterName pname, Int32* param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glSamplerParameteriv((UInt32)sampler, (OpenTK.Graphics.ES30.SamplerParameterName)pname, (Int32*)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define the scissor box
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glScissor")]
        public static 
        void Scissor(Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glScissor((Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, Int32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref Int32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T3)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, Int32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T3)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, UInt32[] shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        void ShaderBinary<T3>(Int32 count, ref UInt32 shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* shaders_ptr = &shaders)
                {
                    GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glShaderBinary((Int32)count, (UInt32*)shaders_ptr, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                        binary = (T3)binary_ptr.Target;
                    }
                    finally
                    {
                        binary_ptr.Free();
                    }
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.All binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.All binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T3)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, IntPtr binary, Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary, (Int32)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] T3[,,] binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Load pre-compiled shader binaries
        /// </summary>
        /// <param name="count">
        /// <para>
        /// Specifies the number of shader object handles contained in shaders.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </para>
        /// </param>
        /// <param name="binaryFormat">
        /// <para>
        /// Specifies the format of the shader binaries contained in binary.
        /// </para>
        /// </param>
        /// <param name="binary">
        /// <para>
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies the length of the array whose address is given in binary.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderBinary")]
        public static 
        unsafe void ShaderBinary<T3>(Int32 count, UInt32* shaders, OpenTK.Graphics.ES30.ShaderBinaryFormat binaryformat, [InAttribute, OutAttribute] ref T3 binary, Int32 length)
            where T3 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
            try
            {
                Delegates.glShaderBinary((Int32)count, (UInt32*)shaders, (OpenTK.Graphics.ES30.ShaderBinaryFormat)binaryformat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                binary = (T3)binary_ptr.Target;
            }
            finally
            {
                binary_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        void ShaderSource(Int32 shader, Int32 count, String[] @string, Int32[] length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        void ShaderSource(Int32 shader, Int32 count, String[] @string, ref Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        unsafe void ShaderSource(Int32 shader, Int32 count, String[] @string, Int32* length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        void ShaderSource(UInt32 shader, Int32 count, String[] @string, Int32[] length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = length)
                {
                    Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        void ShaderSource(UInt32 shader, Int32 count, String[] @string, ref Int32 length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* length_ptr = &length)
                {
                    Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Replaces the source code in a shader object
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the string and length arrays.
        /// </para>
        /// </param>
        /// <param name="string">
        /// <para>
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Specifies an array of string lengths.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glShaderSource")]
        public static 
        unsafe void ShaderSource(UInt32 shader, Int32 count, String[] @string, Int32* length)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glShaderSource((UInt32)shader, (Int32)count, (String[])@string, (Int32*)length);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        public static 
        void StencilFunc(OpenTK.Graphics.ES30.All func, Int32 @ref, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFunc((OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        public static 
        void StencilFunc(OpenTK.Graphics.ES30.All func, Int32 @ref, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFunc((OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        public static 
        void StencilFunc(OpenTK.Graphics.ES30.StencilFunction func, Int32 @ref, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFunc((OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFunc")]
        public static 
        void StencilFunc(OpenTK.Graphics.ES30.StencilFunction func, Int32 @ref, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFunc((OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        public static 
        void StencilFuncSeparate(OpenTK.Graphics.ES30.All face, OpenTK.Graphics.ES30.All func, Int32 @ref, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFuncSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        public static 
        void StencilFuncSeparate(OpenTK.Graphics.ES30.All face, OpenTK.Graphics.ES30.All func, Int32 @ref, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFuncSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        public static 
        void StencilFuncSeparate(OpenTK.Graphics.ES30.StencilFace face, OpenTK.Graphics.ES30.StencilFunction func, Int32 @ref, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFuncSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back function and reference value for stencil testing
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilFuncSeparate")]
        public static 
        void StencilFuncSeparate(OpenTK.Graphics.ES30.StencilFace face, OpenTK.Graphics.ES30.StencilFunction func, Int32 @ref, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilFuncSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilFunction)func, (Int32)@ref, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMask")]
        public static 
        void StencilMask(Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMask((UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMask")]
        public static 
        void StencilMask(UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMask((UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        public static 
        void StencilMaskSeparate(OpenTK.Graphics.ES30.All face, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMaskSeparate((OpenTK.Graphics.ES30.StencilFace)face, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        public static 
        void StencilMaskSeparate(OpenTK.Graphics.ES30.All face, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMaskSeparate((OpenTK.Graphics.ES30.StencilFace)face, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        public static 
        void StencilMaskSeparate(OpenTK.Graphics.ES30.StencilFace face, Int32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMaskSeparate((OpenTK.Graphics.ES30.StencilFace)face, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Control the front and/or back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilMaskSeparate")]
        public static 
        void StencilMaskSeparate(OpenTK.Graphics.ES30.StencilFace face, UInt32 mask)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilMaskSeparate((OpenTK.Graphics.ES30.StencilFace)face, (UInt32)mask);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back stencil test actions
        /// </summary>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOp")]
        public static 
        void StencilOp(OpenTK.Graphics.ES30.All fail, OpenTK.Graphics.ES30.All zfail, OpenTK.Graphics.ES30.All zpass)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilOp((OpenTK.Graphics.ES30.StencilOp)fail, (OpenTK.Graphics.ES30.StencilOp)zfail, (OpenTK.Graphics.ES30.StencilOp)zpass);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and back stencil test actions
        /// </summary>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOp")]
        public static 
        void StencilOp(OpenTK.Graphics.ES30.StencilOp fail, OpenTK.Graphics.ES30.StencilOp zfail, OpenTK.Graphics.ES30.StencilOp zpass)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilOp((OpenTK.Graphics.ES30.StencilOp)fail, (OpenTK.Graphics.ES30.StencilOp)zfail, (OpenTK.Graphics.ES30.StencilOp)zpass);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back stencil test actions
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOpSeparate")]
        public static 
        void StencilOpSeparate(OpenTK.Graphics.ES30.All face, OpenTK.Graphics.ES30.All sfail, OpenTK.Graphics.ES30.All dpfail, OpenTK.Graphics.ES30.All dppass)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilOpSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilOp)sfail, (OpenTK.Graphics.ES30.StencilOp)dpfail, (OpenTK.Graphics.ES30.StencilOp)dppass);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set front and/or back stencil test actions
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glStencilOpSeparate")]
        public static 
        void StencilOpSeparate(OpenTK.Graphics.ES30.StencilFace face, OpenTK.Graphics.ES30.StencilOp sfail, OpenTK.Graphics.ES30.StencilOp dpfail, OpenTK.Graphics.ES30.StencilOp dppass)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glStencilOpSeparate((OpenTK.Graphics.ES30.StencilFace)face, (OpenTK.Graphics.ES30.StencilOp)sfail, (OpenTK.Graphics.ES30.StencilOp)dpfail, (OpenTK.Graphics.ES30.StencilOp)dppass);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T8)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexImage2D")]
        public static 
        void TexImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T8)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[,] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[,,] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T9 pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T9)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// This value must be 0.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexImage3D")]
        public static 
        void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
            where T9 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T9)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterf")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameterf((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterf")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Single param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameterf((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        public static 
        unsafe void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Single[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* @params_ptr = @params)
                {
                    Delegates.glTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameterfv")]
        public static 
        unsafe void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Single* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameterfv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Single*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteri")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameteri((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteri")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Int32 param)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameteri((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32)param);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        public static 
        unsafe void TexParameter(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        public static 
        void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Int32[] @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* @params_ptr = @params)
                {
                    Delegates.glTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32*)@params_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </para>
        /// <para>
        /// For the vector commands (glTexParameter*v), pname can also be one of GL_TEXTURE_BORDER_COLOR or GL_TEXTURE_SWIZZLE_RGBA.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// For the scalar commands, specifies the value of pname.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexParameteriv")]
        public static 
        unsafe void TexParameter(OpenTK.Graphics.ES30.TextureTarget target, OpenTK.Graphics.ES30.TextureParameterName pname, Int32* @params)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexParameteriv((OpenTK.Graphics.ES30.TextureTarget)target, (OpenTK.Graphics.ES30.TextureParameterName)pname, (Int32*)@params);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the operation. target must be one of GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="levels">
        /// <para>
        /// Specify the number of texture levels.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the sized internal format to be used to store texture image data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture, in texels.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage2D")]
        public static 
        void TexStorage2D(OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexStorage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the operation. target must be one of GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="levels">
        /// <para>
        /// Specify the number of texture levels.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the sized internal format to be used to store texture image data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture, in texels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage2D")]
        public static 
        void TexStorage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 levels, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexStorage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the operation. target must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="levels">
        /// <para>
        /// Specify the number of texture levels.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the sized internal format to be used to store texture image data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture, in texels.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage3D")]
        public static 
        void TexStorage3D(OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexStorage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specify the target of the operation. target must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_ARRAY.
        /// </para>
        /// </param>
        /// <param name="levels">
        /// <para>
        /// Specify the number of texture levels.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the sized internal format to be used to store texture image data.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture, in texels.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture, in texels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexStorage3D")]
        public static 
        void TexStorage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 levels, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexStorage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T8)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glTexSubImage2D")]
        public static 
        void TexSubImage2D<T8>(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage2D((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T8)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,,] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T10 pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T10)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, IntPtr pixels)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTexSubImage3D")]
        public static 
        void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
            where T10 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try
            {
                Delegates.glTexSubImage3D((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                pixels = (T10)pixels_ptr.Target;
            }
            finally
            {
                pixels_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The number of varying variables used for transform feedback.
        /// </para>
        /// </param>
        /// <param name="varyings">
        /// <para>
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </para>
        /// </param>
        /// <param name="bufferMode">
        /// <para>
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        public static 
        void TransformFeedbackVaryings(Int32 program, Int32 count, String[] varyings, OpenTK.Graphics.ES30.All bufferMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTransformFeedbackVaryings((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.ES30.TransformFeedbackMode)bufferMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The number of varying variables used for transform feedback.
        /// </para>
        /// </param>
        /// <param name="varyings">
        /// <para>
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </para>
        /// </param>
        /// <param name="bufferMode">
        /// <para>
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        public static 
        void TransformFeedbackVaryings(Int32 program, Int32 count, String[] varyings, OpenTK.Graphics.ES30.TransformFeedbackMode bufferMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTransformFeedbackVaryings((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.ES30.TransformFeedbackMode)bufferMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The number of varying variables used for transform feedback.
        /// </para>
        /// </param>
        /// <param name="varyings">
        /// <para>
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </para>
        /// </param>
        /// <param name="bufferMode">
        /// <para>
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        public static 
        void TransformFeedbackVaryings(UInt32 program, Int32 count, String[] varyings, OpenTK.Graphics.ES30.All bufferMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTransformFeedbackVaryings((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.ES30.TransformFeedbackMode)bufferMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify values to record in transform feedback buffers
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of the target program object.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// The number of varying variables used for transform feedback.
        /// </para>
        /// </param>
        /// <param name="varyings">
        /// <para>
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.
        /// </para>
        /// </param>
        /// <param name="bufferMode">
        /// <para>
        /// Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glTransformFeedbackVaryings")]
        public static 
        void TransformFeedbackVaryings(UInt32 program, Int32 count, String[] varyings, OpenTK.Graphics.ES30.TransformFeedbackMode bufferMode)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glTransformFeedbackVaryings((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.ES30.TransformFeedbackMode)bufferMode);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1f")]
        public static 
        void Uniform1(Int32 location, Single v0)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1f((Int32)location, (Single)v0);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        public static 
        void Uniform1(Int32 location, Int32 count, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniform1fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        public static 
        void Uniform1(Int32 location, Int32 count, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniform1fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1fv")]
        public static 
        unsafe void Uniform1(Int32 location, Int32 count, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1fv((Int32)location, (Int32)count, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1i")]
        public static 
        void Uniform1(Int32 location, Int32 v0)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1i((Int32)location, (Int32)v0);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        public static 
        void Uniform1(Int32 location, Int32 count, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glUniform1iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        public static 
        void Uniform1(Int32 location, Int32 count, ref Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = &value)
                {
                    Delegates.glUniform1iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform1iv")]
        public static 
        unsafe void Uniform1(Int32 location, Int32 count, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1iv((Int32)location, (Int32)count, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1ui")]
        public static 
        void Uniform1(Int32 location, UInt32 v0)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1ui((Int32)location, (UInt32)v0);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        public static 
        void Uniform1(Int32 location, Int32 count, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glUniform1uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        public static 
        void Uniform1(Int32 location, Int32 count, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glUniform1uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform1uiv")]
        public static 
        unsafe void Uniform1(Int32 location, Int32 count, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform1uiv((Int32)location, (Int32)count, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2f")]
        public static 
        void Uniform2(Int32 location, Single v0, Single v1)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2f((Int32)location, (Single)v0, (Single)v1);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        public static 
        void Uniform2(Int32 location, Int32 count, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniform2fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        public static 
        void Uniform2(Int32 location, Int32 count, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniform2fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2fv")]
        public static 
        unsafe void Uniform2(Int32 location, Int32 count, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2fv((Int32)location, (Int32)count, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2i")]
        public static 
        void Uniform2(Int32 location, Int32 v0, Int32 v1)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2i((Int32)location, (Int32)v0, (Int32)v1);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2iv")]
        public static 
        void Uniform2(Int32 location, Int32 count, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glUniform2iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform2iv")]
        public static 
        unsafe void Uniform2(Int32 location, Int32 count, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2iv((Int32)location, (Int32)count, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2ui")]
        public static 
        void Uniform2(Int32 location, UInt32 v0, UInt32 v1)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2ui((Int32)location, (UInt32)v0, (UInt32)v1);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        public static 
        void Uniform2(Int32 location, Int32 count, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glUniform2uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        public static 
        void Uniform2(Int32 location, Int32 count, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glUniform2uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform2uiv")]
        public static 
        unsafe void Uniform2(Int32 location, Int32 count, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform2uiv((Int32)location, (Int32)count, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3f")]
        public static 
        void Uniform3(Int32 location, Single v0, Single v1, Single v2)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3f((Int32)location, (Single)v0, (Single)v1, (Single)v2);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        public static 
        void Uniform3(Int32 location, Int32 count, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniform3fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        public static 
        void Uniform3(Int32 location, Int32 count, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniform3fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3fv")]
        public static 
        unsafe void Uniform3(Int32 location, Int32 count, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3fv((Int32)location, (Int32)count, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3i")]
        public static 
        void Uniform3(Int32 location, Int32 v0, Int32 v1, Int32 v2)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3i((Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        public static 
        void Uniform3(Int32 location, Int32 count, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glUniform3iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        public static 
        void Uniform3(Int32 location, Int32 count, ref Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = &value)
                {
                    Delegates.glUniform3iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform3iv")]
        public static 
        unsafe void Uniform3(Int32 location, Int32 count, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3iv((Int32)location, (Int32)count, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3ui")]
        public static 
        void Uniform3(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3ui((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        public static 
        void Uniform3(Int32 location, Int32 count, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glUniform3uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        public static 
        void Uniform3(Int32 location, Int32 count, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glUniform3uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform3uiv")]
        public static 
        unsafe void Uniform3(Int32 location, Int32 count, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform3uiv((Int32)location, (Int32)count, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4f")]
        public static 
        void Uniform4(Int32 location, Single v0, Single v1, Single v2, Single v3)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4f((Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        public static 
        void Uniform4(Int32 location, Int32 count, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniform4fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        public static 
        void Uniform4(Int32 location, Int32 count, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniform4fv((Int32)location, (Int32)count, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4fv")]
        public static 
        unsafe void Uniform4(Int32 location, Int32 count, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4fv((Int32)location, (Int32)count, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4i")]
        public static 
        void Uniform4(Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4i((Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        public static 
        void Uniform4(Int32 location, Int32 count, Int32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = value)
                {
                    Delegates.glUniform4iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        public static 
        void Uniform4(Int32 location, Int32 count, ref Int32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* value_ptr = &value)
                {
                    Delegates.glUniform4iv((Int32)location, (Int32)count, (Int32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniform4iv")]
        public static 
        unsafe void Uniform4(Int32 location, Int32 count, Int32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4iv((Int32)location, (Int32)count, (Int32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4ui")]
        public static 
        void Uniform4(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4ui((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2, (UInt32)v3);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        public static 
        void Uniform4(Int32 location, Int32 count, UInt32[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = value)
                {
                    Delegates.glUniform4uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        public static 
        void Uniform4(Int32 location, Int32 count, ref UInt32 value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* value_ptr = &value)
                {
                    Delegates.glUniform4uiv((Int32)location, (Int32)count, (UInt32*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Specify the value of a uniform variable for the current program object
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable to be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// For the vector (glUniform*v) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
        /// </para>
        /// <para>
        /// For the matrix (glUniformMatrix*) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniform4uiv")]
        public static 
        unsafe void Uniform4(Int32 location, Int32 count, UInt32* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniform4uiv((Int32)location, (Int32)count, (UInt32*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Assign a binding point to an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of a program object containing the active uniform block whose binding to assign.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// The index of the active uniform block within program whose binding to assign.
        /// </para>
        /// </param>
        /// <param name="uniformBlockBinding">
        /// <para>
        /// Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformBlockBinding")]
        public static 
        void UniformBlockBinding(Int32 program, Int32 uniformBlockIndex, Int32 uniformBlockBinding)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformBlockBinding((UInt32)program, (UInt32)uniformBlockIndex, (UInt32)uniformBlockBinding);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Assign a binding point to an active uniform block
        /// </summary>
        /// <param name="program">
        /// <para>
        /// The name of a program object containing the active uniform block whose binding to assign.
        /// </para>
        /// </param>
        /// <param name="uniformBlockIndex">
        /// <para>
        /// The index of the active uniform block within program whose binding to assign.
        /// </para>
        /// </param>
        /// <param name="uniformBlockBinding">
        /// <para>
        /// Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformBlockBinding")]
        public static 
        void UniformBlockBinding(UInt32 program, UInt32 uniformBlockIndex, UInt32 uniformBlockBinding)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformBlockBinding((UInt32)program, (UInt32)uniformBlockIndex, (UInt32)uniformBlockBinding);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        public static 
        void UniformMatrix2(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        public static 
        void UniformMatrix2(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix2fv")]
        public static 
        unsafe void UniformMatrix2(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        public static 
        void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix2x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        public static 
        void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix2x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x3fv")]
        public static 
        unsafe void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix2x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        public static 
        void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix2x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        public static 
        void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix2x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix2x4fv")]
        public static 
        unsafe void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix2x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        public static 
        void UniformMatrix3(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        public static 
        void UniformMatrix3(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix3fv")]
        public static 
        unsafe void UniformMatrix3(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        public static 
        void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix3x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        public static 
        void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix3x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x2fv")]
        public static 
        unsafe void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix3x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        public static 
        void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix3x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        public static 
        void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix3x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix3x4fv")]
        public static 
        unsafe void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix3x4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        public static 
        void UniformMatrix4(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        public static 
        void UniformMatrix4(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUniformMatrix4fv")]
        public static 
        unsafe void UniformMatrix4(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix4fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        public static 
        void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix4x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        public static 
        void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix4x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x2fv")]
        public static 
        unsafe void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix4x2fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        public static 
        void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, Single[] value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = value)
                {
                    Delegates.glUniformMatrix4x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        public static 
        void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, ref Single value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* value_ptr = &value)
                {
                    Delegates.glUniformMatrix4x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUniformMatrix4x3fv")]
        public static 
        unsafe void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, Single* value)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUniformMatrix4x3fv((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUnmapBuffer")]
        public static 
        bool UnmapBuffer(OpenTK.Graphics.ES30.All target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glUnmapBuffer((OpenTK.Graphics.ES30.BufferTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glUnmapBuffer")]
        public static 
        bool UnmapBuffer(OpenTK.Graphics.ES30.BufferTarget target)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            return Delegates.glUnmapBuffer((OpenTK.Graphics.ES30.BufferTarget)target);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Installs a program object as part of current rendering state
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object whose executables are to be used as part of current rendering state.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUseProgram")]
        public static 
        void UseProgram(Int32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUseProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Installs a program object as part of current rendering state
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object whose executables are to be used as part of current rendering state.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glUseProgram")]
        public static 
        void UseProgram(UInt32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glUseProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Validates a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to be validated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glValidateProgram")]
        public static 
        void ValidateProgram(Int32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glValidateProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Validates a program object
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to be validated.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glValidateProgram")]
        public static 
        void ValidateProgram(UInt32 program)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glValidateProgram((UInt32)program);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1f")]
        public static 
        void VertexAttrib1(Int32 index, Single x)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib1f((UInt32)index, (Single)x);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1f")]
        public static 
        void VertexAttrib1(UInt32 index, Single x)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib1f((UInt32)index, (Single)x);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1fv")]
        public static 
        unsafe void VertexAttrib1(Int32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib1fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib1fv")]
        public static 
        unsafe void VertexAttrib1(UInt32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib1fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2f")]
        public static 
        void VertexAttrib2(Int32 index, Single x, Single y)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib2f((UInt32)index, (Single)x, (Single)y);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2f")]
        public static 
        void VertexAttrib2(UInt32 index, Single x, Single y)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib2f((UInt32)index, (Single)x, (Single)y);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        void VertexAttrib2(Int32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        void VertexAttrib2(Int32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        unsafe void VertexAttrib2(Int32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        void VertexAttrib2(UInt32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        void VertexAttrib2(UInt32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib2fv")]
        public static 
        unsafe void VertexAttrib2(UInt32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib2fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3f")]
        public static 
        void VertexAttrib3(Int32 index, Single x, Single y, Single z)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib3f((UInt32)index, (Single)x, (Single)y, (Single)z);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3f")]
        public static 
        void VertexAttrib3(UInt32 index, Single x, Single y, Single z)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib3f((UInt32)index, (Single)x, (Single)y, (Single)z);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        void VertexAttrib3(Int32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        void VertexAttrib3(Int32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        unsafe void VertexAttrib3(Int32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        void VertexAttrib3(UInt32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        void VertexAttrib3(UInt32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib3fv")]
        public static 
        unsafe void VertexAttrib3(UInt32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib3fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4f")]
        public static 
        void VertexAttrib4(Int32 index, Single x, Single y, Single z, Single w)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib4f((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4f")]
        public static 
        void VertexAttrib4(UInt32 index, Single x, Single y, Single z, Single w)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib4f((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        void VertexAttrib4(Int32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        void VertexAttrib4(Int32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        unsafe void VertexAttrib4(Int32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        void VertexAttrib4(UInt32 index, Single[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = v)
                {
                    Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        void VertexAttrib4(UInt32 index, ref Single v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Single* v_ptr = &v)
                {
                    Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Specifies the value of a generic vertex attribute
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v0">
        /// <para>
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// For the vector commands (glVertexAttrib*v), specifies a pointer to an array of values to be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// For the packed commands (glVertexAttribP*), specified the type of packing used on the data. This parameter must be GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV, to specify signed or unsigned data, respectively, or GL_UNSIGNED_INT_10F_11F_11F_REV to specify floating point data.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For the packed commands, if GL_TRUE, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If type indicates a floating-pont format, then normalized value must be GL_FALSE.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttrib4fv")]
        public static 
        unsafe void VertexAttrib4(UInt32 index, Single* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttrib4fv((UInt32)index, (Single*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Modify the rate at which generic vertex attributes advance during instanced rendering
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specify the index of the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="divisor">
        /// <para>
        /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribDivisor")]
        public static 
        void VertexAttribDivisor(Int32 index, Int32 divisor)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribDivisor((UInt32)index, (UInt32)divisor);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Modify the rate at which generic vertex attributes advance during instanced rendering
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specify the index of the generic vertex attribute.
        /// </para>
        /// </param>
        /// <param name="divisor">
        /// <para>
        /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribDivisor")]
        public static 
        void VertexAttribDivisor(UInt32 index, UInt32 divisor)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribDivisor((UInt32)index, (UInt32)divisor);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4i")]
        public static 
        void VertexAttribI4(Int32 index, Int32 x, Int32 y, Int32 z, Int32 w)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4i((UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4i")]
        public static 
        void VertexAttribI4(UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4i((UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        void VertexAttribI4(Int32 index, Int32[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* v_ptr = v)
                {
                    Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        void VertexAttribI4(Int32 index, ref Int32 v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* v_ptr = &v)
                {
                    Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        unsafe void VertexAttribI4(Int32 index, Int32* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        void VertexAttribI4(UInt32 index, Int32[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* v_ptr = v)
                {
                    Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        void VertexAttribI4(UInt32 index, ref Int32 v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (Int32* v_ptr = &v)
                {
                    Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4iv")]
        public static 
        unsafe void VertexAttribI4(UInt32 index, Int32* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4iv((UInt32)index, (Int32*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4ui")]
        public static 
        void VertexAttribI4(UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4ui((UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z, (UInt32)w);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        public static 
        void VertexAttribI4(UInt32 index, UInt32[] v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* v_ptr = v)
                {
                    Delegates.glVertexAttribI4uiv((UInt32)index, (UInt32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        public static 
        void VertexAttribI4(UInt32 index, ref UInt32 v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            unsafe
            {
                fixed (UInt32* v_ptr = &v)
                {
                    Delegates.glVertexAttribI4uiv((UInt32)index, (UInt32*)v_ptr);
                }
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribI4uiv")]
        public static 
        unsafe void VertexAttribI4(UInt32 index, UInt32* v)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribI4uiv((UInt32)index, (UInt32*)v);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T4)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T4)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T4)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]</summary>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glVertexAttribIPointer")]
        public static 
        void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribIntegerType type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
            where T4 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribIPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribIntegerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T4)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T5)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T5)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.All type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T5)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, IntPtr pointer)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Define an array of generic vertex attribute data
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glVertexAttribPointer")]
        public static 
        void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.ES30.VertexAttribPointerType type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
            where T5 : struct
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try
            {
                Delegates.glVertexAttribPointer((UInt32)index, (Int32)size, (OpenTK.Graphics.ES30.VertexAttribPointerType)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                pointer = (T5)pointer_ptr.Target;
            }
            finally
            {
                pointer_ptr.Free();
            }
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v2.0 and ES_VERSION_2_0]
        /// Set the viewport
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_2_0", Version = "2.0", EntryPoint = "glViewport")]
        public static 
        void Viewport(Int32 x, Int32 y, Int32 width, Int32 height)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glViewport((Int32)x, (Int32)y, (Int32)width, (Int32)height);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        public static 
        void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, Int64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
        /// </para>
        /// </param>
        [Obsolete("Use strongly-typed overload instead")]
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        public static 
        void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.All flags, UInt64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        public static 
        void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.WaitSyncFlags flags, Int64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        /// <summary>[requires: v3.0 and ES_VERSION_3_0]
        /// Instruct the GL server to block until the specified sync object becomes signaled
        /// </summary>
        /// <param name="sync">
        /// <para>
        /// Specifies the sync object whose status to wait on.
        /// </para>
        /// </param>
        /// <param name="flags">
        /// <para>
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </para>
        /// </param>
        /// <param name="timeout">
        /// <para>
        /// Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ES_VERSION_3_0", Version = "3.0", EntryPoint = "glWaitSync")]
        public static 
        void WaitSync(IntPtr sync, OpenTK.Graphics.ES30.WaitSyncFlags flags, UInt64 timeout)
        {
            #if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
            #endif
            Delegates.glWaitSync((IntPtr)sync, (OpenTK.Graphics.ES30.WaitSyncFlags)flags, (UInt64)timeout);
            #if DEBUG
            }
            #endif
        }

        public static partial class Ext
        {
            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveProgramEXT")]
            public static 
            void ActiveProgram(Int32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glActiveProgramEXT((UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveProgramEXT")]
            public static 
            void ActiveProgram(UInt32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glActiveProgramEXT((UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Set the active program object for a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the program pipeline object to set the active program object for.
            /// </para>
            /// </param>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to set as the active program pipeline object pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveShaderProgramEXT")]
            public static 
            void ActiveShaderProgram(Int32 pipeline, Int32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glActiveShaderProgramEXT((UInt32)pipeline, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Set the active program object for a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the program pipeline object to set the active program object for.
            /// </para>
            /// </param>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to set as the active program pipeline object pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glActiveShaderProgramEXT")]
            public static 
            void ActiveShaderProgram(UInt32 pipeline, UInt32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glActiveShaderProgramEXT((UInt32)pipeline, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            public static 
            void BeginQuery(OpenTK.Graphics.ES30.All target, Int32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            public static 
            void BeginQuery(OpenTK.Graphics.ES30.All target, UInt32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            public static 
            void BeginQuery(OpenTK.Graphics.ES30.QueryTarget target, Int32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glBeginQueryEXT")]
            public static 
            void BeginQuery(OpenTK.Graphics.ES30.QueryTarget target, UInt32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBeginQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target, (UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind a program pipeline to the current context
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of the pipeline object to bind to the context.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glBindProgramPipelineEXT")]
            public static 
            void BindProgramPipeline(Int32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBindProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind a program pipeline to the current context
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of the pipeline object to bind to the context.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glBindProgramPipelineEXT")]
            public static 
            void BindProgramPipeline(UInt32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBindProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_blend_minmax]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// <para>
            /// for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.
            /// </para>
            /// </param>
            /// <param name="mode">
            /// <para>
            /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_blend_minmax", Version = "", EntryPoint = "glBlendEquationEXT")]
            public static 
            void BlendEquation(OpenTK.Graphics.ES30.All mode)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlendEquationEXT((OpenTK.Graphics.ES30.BlendEquationMode)mode);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_blend_minmax]
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="buf">
            /// <para>
            /// for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.
            /// </para>
            /// </param>
            /// <param name="mode">
            /// <para>
            /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_blend_minmax", Version = "", EntryPoint = "glBlendEquationEXT")]
            public static 
            void BlendEquation(OpenTK.Graphics.ES30.BlendEquationMode mode)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlendEquationEXT((OpenTK.Graphics.ES30.BlendEquationMode)mode);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Create a stand-alone program from an array of null-terminated source code strings
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the type of shader to create.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of source code strings in the array strings.
            /// </para>
            /// </param>
            /// <param name="strings">
            /// <para>
            /// Specifies the address of an array of pointers to source code strings from which to create the program object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glCreateShaderProgramEXT")]
            public static 
            Int32 CreateShaderProgram(OpenTK.Graphics.ES30.All type, String @string)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glCreateShaderProgramEXT((OpenTK.Graphics.ES30.All)type, (String)@string);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Create a stand-alone program from an array of null-terminated source code strings
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the type of shader to create.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of source code strings in the array strings.
            /// </para>
            /// </param>
            /// <param name="strings">
            /// <para>
            /// Specifies the address of an array of pointers to source code strings from which to create the program object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glCreateShaderProgramvEXT")]
            public static 
            Int32 CreateShaderProgram(OpenTK.Graphics.ES30.All type, Int32 count, String[] strings)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glCreateShaderProgramvEXT((OpenTK.Graphics.ES30.All)type, (Int32)count, (String[])strings);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipeline(Int32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* pipelines_ptr = (UInt32*)&pipelines;
                    Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipeline(UInt32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* pipelines_ptr = (UInt32*)&pipelines;
                    Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipelines(Int32 n, Int32[] pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* pipelines_ptr = pipelines)
                    {
                        Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipelines(Int32 n, ref Int32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* pipelines_ptr = &pipelines)
                    {
                        Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            unsafe void DeleteProgramPipelines(Int32 n, Int32* pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipelines(Int32 n, UInt32[] pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* pipelines_ptr = pipelines)
                    {
                        Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            void DeleteProgramPipelines(Int32 n, ref UInt32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* pipelines_ptr = &pipelines)
                    {
                        Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Delete program pipeline objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline objects to delete.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of names of program pipeline objects to delete.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glDeleteProgramPipelinesEXT")]
            public static 
            unsafe void DeleteProgramPipelines(Int32 n, UInt32* pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteProgramPipelinesEXT((Int32)n, (UInt32*)pipelines);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQuery(Int32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* ids_ptr = (UInt32*)&ids;
                    Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQuery(UInt32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* ids_ptr = (UInt32*)&ids;
                    Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQueries(Int32 n, Int32[] ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = ids)
                    {
                        Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQueries(Int32 n, ref Int32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = &ids)
                    {
                        Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            unsafe void DeleteQueries(Int32 n, Int32* ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQueries(Int32 n, UInt32[] ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = ids)
                    {
                        Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            void DeleteQueries(Int32 n, ref UInt32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = &ids)
                    {
                        Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glDeleteQueriesEXT")]
            public static 
            unsafe void DeleteQueries(Int32 n, UInt32* ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteQueriesEXT((Int32)n, (UInt32*)ids);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            public static 
            void DiscardFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All[] attachments)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* attachments_ptr = attachments)
                    {
                        Delegates.glDiscardFramebufferEXT((OpenTK.Graphics.ES30.All)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.All*)attachments_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            public static 
            void DiscardFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, ref OpenTK.Graphics.ES30.All attachments)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* attachments_ptr = &attachments)
                    {
                        Delegates.glDiscardFramebufferEXT((OpenTK.Graphics.ES30.All)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.All*)attachments_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_discard_framebuffer]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_discard_framebuffer", Version = "", EntryPoint = "glDiscardFramebufferEXT")]
            public static 
            unsafe void DiscardFramebuffer(OpenTK.Graphics.ES30.All target, Int32 numAttachments, OpenTK.Graphics.ES30.All* attachments)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDiscardFramebufferEXT((OpenTK.Graphics.ES30.All)target, (Int32)numAttachments, (OpenTK.Graphics.ES30.All*)attachments);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedEXT")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.All mode, Int32 start, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)start, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawArraysInstancedEXT")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 start, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)start, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All[] bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* bufs_ptr = bufs)
                    {
                        Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.All bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* bufs_ptr = &bufs)
                    {
                        Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All* bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode[] bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = bufs)
                    {
                        Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.DrawBufferMode bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = &bufs)
                    {
                        Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_draw_buffers", Version = "", EntryPoint = "glDrawBuffersEXT")]
            public static 
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode* bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawBuffersEXT((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            public static 
            void DrawBuffersIndexed(Int32 n, OpenTK.Graphics.ES30.All[] location, Int32[] indices)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* location_ptr = location)
                    fixed (Int32* indices_ptr = indices)
                    {
                        Delegates.glDrawBuffersIndexedEXT((Int32)n, (OpenTK.Graphics.ES30.All*)location_ptr, (Int32*)indices_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            public static 
            void DrawBuffersIndexed(Int32 n, ref OpenTK.Graphics.ES30.All location, ref Int32 indices)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* location_ptr = &location)
                    fixed (Int32* indices_ptr = &indices)
                    {
                        Delegates.glDrawBuffersIndexedEXT((Int32)n, (OpenTK.Graphics.ES30.All*)location_ptr, (Int32*)indices_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glDrawBuffersIndexedEXT")]
            public static 
            unsafe void DrawBuffersIndexed(Int32 n, OpenTK.Graphics.ES30.All* location, Int32* indices)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawBuffersIndexedEXT((Int32)n, (OpenTK.Graphics.ES30.All*)location, (Int32*)indices);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_draw_instanced|EXT_instanced_arrays]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_draw_instanced|EXT_instanced_arrays", Version = "", EntryPoint = "glDrawElementsInstancedEXT")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glEndQueryEXT")]
            public static 
            void EndQuery(OpenTK.Graphics.ES30.All target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glEndQueryEXT")]
            public static 
            void EndQuery(OpenTK.Graphics.ES30.QueryTarget target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndQueryEXT((OpenTK.Graphics.ES30.QueryTarget)target);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Indicate modifications to a range of a mapped buffer
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target of the flush operation. target must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the start of the buffer subrange, in basic machine units.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the length of the buffer subrange, in basic machine units.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glFlushMappedBufferRangeEXT")]
            public static 
            void FlushMappedBufferRange(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFlushMappedBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Indicate modifications to a range of a mapped buffer
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target of the flush operation. target must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the start of the buffer subrange, in basic machine units.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the length of the buffer subrange, in basic machine units.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glFlushMappedBufferRangeEXT")]
            public static 
            void FlushMappedBufferRange(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFlushMappedBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multisampled_render_to_texture]</summary>
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleEXT")]
            public static 
            void FramebufferTexture2DMultisample(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, Int32 texture, Int32 level, Int32 samples)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture2DMultisampleEXT((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)samples);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multisampled_render_to_texture]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleEXT")]
            public static 
            void FramebufferTexture2DMultisample(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, UInt32 texture, Int32 level, Int32 samples)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture2DMultisampleEXT((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)samples);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            Int32 GenProgramPipeline()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    Int32 retval;
                    Int32* pipelines_ptr = &retval;
                    Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            void GenProgramPipelines(Int32 n, [OutAttribute] Int32[] pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* pipelines_ptr = pipelines)
                    {
                        Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            void GenProgramPipelines(Int32 n, [OutAttribute] out Int32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* pipelines_ptr = &pipelines)
                    {
                        Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                        pipelines = *pipelines_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            unsafe void GenProgramPipelines(Int32 n, [OutAttribute] Int32* pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            void GenProgramPipelines(Int32 n, [OutAttribute] UInt32[] pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* pipelines_ptr = pipelines)
                    {
                        Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            void GenProgramPipelines(Int32 n, [OutAttribute] out UInt32 pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* pipelines_ptr = &pipelines)
                    {
                        Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines_ptr);
                        pipelines = *pipelines_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Reserve program pipeline object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of program pipeline object names to reserve.
            /// </para>
            /// </param>
            /// <param name="pipelines">
            /// <para>
            /// Specifies an array of into which the reserved names will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGenProgramPipelinesEXT")]
            public static 
            unsafe void GenProgramPipelines(Int32 n, [OutAttribute] UInt32* pipelines)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenProgramPipelinesEXT((Int32)n, (UInt32*)pipelines);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            Int32 GenQuery()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    Int32 retval;
                    Int32* ids_ptr = &retval;
                    Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            void GenQueries(Int32 n, [OutAttribute] Int32[] ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = ids)
                    {
                        Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            void GenQueries(Int32 n, [OutAttribute] out Int32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = &ids)
                    {
                        Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                        ids = *ids_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            unsafe void GenQueries(Int32 n, [OutAttribute] Int32* ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            void GenQueries(Int32 n, [OutAttribute] UInt32[] ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = ids)
                    {
                        Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            void GenQueries(Int32 n, [OutAttribute] out UInt32 ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = &ids)
                    {
                        Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids_ptr);
                        ids = *ids_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGenQueriesEXT")]
            public static 
            unsafe void GenQueries(Int32 n, [OutAttribute] UInt32* ids)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenQueriesEXT((Int32)n, (UInt32*)ids);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetGraphicsResetStatusEXT")]
            public static 
            OpenTK.Graphics.ES30.All GetGraphicsResetStatus()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glGetGraphicsResetStatusEXT();
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int32[] data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] out Int32 data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = &data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                        data = *data_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            unsafe void GetInteger(OpenTK.Graphics.ES30.All target, Int32 index, [OutAttribute] Int32* data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int32[] data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] out Int32 data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = &data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                        data = *data_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            unsafe void GetInteger(OpenTK.Graphics.ES30.All target, UInt32 index, [OutAttribute] Int32* data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int32[] data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] out Int32 data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = &data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                        data = *data_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            unsafe void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, Int32 index, [OutAttribute] Int32* data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int32[] data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] out Int32 data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* data_ptr = &data)
                    {
                        Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data_ptr);
                        data = *data_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glGetIntegeri_vEXT")]
            public static 
            unsafe void GetInteger(OpenTK.Graphics.ES30.GetIndexedPName target, UInt32 index, [OutAttribute] Int32* data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetIntegeri_vEXT((OpenTK.Graphics.ES30.GetIndexedPName)target, (UInt32)index, (Int32*)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Single @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformfvEXT")]
            public static 
            unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Single* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetnUniformfvEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Single*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            unsafe void GetnUniform(Int32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glGetnUniformivEXT")]
            public static 
            unsafe void GetnUniform(UInt32 program, Int32 location, Int32 bufSize, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetnUniformivEXT((UInt32)program, (Int32)location, (Int32)bufSize, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All type, Int32 @object, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All type, Int32 @object, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All type, Int32 @object, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All type, UInt32 @object, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All type, UInt32 @object, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glGetObjectLabelEXT")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All type, UInt32 @object, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            unsafe void GetProgramPipelineInfoLog(Int32 pipeline, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)infoLog);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve the info log string from a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object from which to retrieve the info log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable into which will be written the number of characters written into infoLog.
            /// </para>
            /// </param>
            /// <param name="infoLog">
            /// <para>
            /// Specifies the address of an array of characters into which will be written the info log for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineInfoLogEXT")]
            public static 
            unsafe void GetProgramPipelineInfoLog(UInt32 pipeline, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramPipelineInfoLogEXT((UInt32)pipeline, (Int32)bufSize, (Int32*)length, (StringBuilder)infoLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            unsafe void GetProgramPipeline(Int32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Retrieve properties of a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object whose parameter retrieve.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to retrieve.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Specifies the address of a variable into which will be written the value or values of pname for pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glGetProgramPipelineivEXT")]
            public static 
            unsafe void GetProgramPipeline(UInt32 pipeline, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramPipelineivEXT((UInt32)pipeline, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            unsafe void GetQuery(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryivEXT")]
            public static 
            unsafe void GetQuery(OpenTK.Graphics.ES30.QueryTarget target, OpenTK.Graphics.ES30.GetQueryParam pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryivEXT((OpenTK.Graphics.ES30.QueryTarget)target, (OpenTK.Graphics.ES30.GetQueryParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out Int64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjecti64vEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjecti64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectivEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out UInt64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt64[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt64* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out UInt64 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt64* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glGetQueryObjectui64vEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt64* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectui64vEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt64*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] out UInt32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.All pname, [OutAttribute] UInt32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* @params_ptr = @params)
                    {
                        Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] out UInt32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* @params_ptr = &@params)
                    {
                        Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to receive the resulting data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glGetQueryObjectuivEXT")]
            public static 
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.ES30.GetQueryObjectParam pname, [OutAttribute] UInt32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetQueryObjectuivEXT((UInt32)id, (OpenTK.Graphics.ES30.GetQueryObjectParam)pname, (UInt32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_marker]</summary>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glInsertEventMarkerEXT")]
            public static 
            void InsertEventMarker(Int32 length, String marker)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glInsertEventMarkerEXT((Int32)length, (String)marker);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Determine if a name corresponds to a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies a value that may be the name of a program pipeline object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glIsProgramPipelineEXT")]
            public static 
            bool IsProgramPipeline(Int32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Determine if a name corresponds to a program pipeline object
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies a value that may be the name of a program pipeline object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glIsProgramPipelineEXT")]
            public static 
            bool IsProgramPipeline(UInt32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies a value that may be the name of a query object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glIsQueryEXT")]
            public static 
            bool IsQuery(Int32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsQueryEXT((UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query|EXT_occlusion_query_boolean]
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies a value that may be the name of a query object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query|EXT_occlusion_query_boolean", Version = "", EntryPoint = "glIsQueryEXT")]
            public static 
            bool IsQuery(UInt32 id)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsQueryEXT((UInt32)id);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]</summary>
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glLabelObjectEXT")]
            public static 
            void LabelObject(OpenTK.Graphics.ES30.All type, Int32 @object, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glLabelObjectEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_label]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_debug_label", Version = "", EntryPoint = "glLabelObjectEXT")]
            public static 
            void LabelObject(OpenTK.Graphics.ES30.All type, UInt32 @object, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glLabelObjectEXT((OpenTK.Graphics.ES30.All)type, (UInt32)@object, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target buffer is bound.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies a the starting offset within the buffer of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies a length of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            public static 
            IntPtr MapBufferRange(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr length, Int32 access)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glMapBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (UInt32)access);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target buffer is bound.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies a the starting offset within the buffer of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies a length of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            public static 
            IntPtr MapBufferRange(OpenTK.Graphics.ES30.All target, IntPtr offset, IntPtr length, UInt32 access)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glMapBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (UInt32)access);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target buffer is bound.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies a the starting offset within the buffer of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies a length of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            public static 
            IntPtr MapBufferRange(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr length, Int32 access)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glMapBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (UInt32)access);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_map_buffer_range]
            /// Map a section of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target buffer is bound.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies a the starting offset within the buffer of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies a length of the range to be mapped.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// Specifies a combination of access flags indicating the desired access to the range.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_map_buffer_range", Version = "", EntryPoint = "glMapBufferRangeEXT")]
            public static 
            IntPtr MapBufferRange(OpenTK.Graphics.ES30.BufferTarget target, IntPtr offset, IntPtr length, UInt32 access)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glMapBufferRangeEXT((OpenTK.Graphics.ES30.BufferTarget)target, (IntPtr)offset, (IntPtr)length, (UInt32)access);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            void MultiDrawArrays(OpenTK.Graphics.ES30.All mode, Int32[] first, Int32[] count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* first_ptr = first)
                    fixed (Int32* count_ptr = count)
                    {
                        Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            void MultiDrawArrays(OpenTK.Graphics.ES30.All mode, ref Int32 first, ref Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* first_ptr = &first)
                    fixed (Int32* count_ptr = &count)
                    {
                        Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            unsafe void MultiDrawArrays(OpenTK.Graphics.ES30.All mode, Int32* first, Int32* count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first, (Int32*)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            void MultiDrawArrays(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] first, Int32[] count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* first_ptr = first)
                    fixed (Int32* count_ptr = count)
                    {
                        Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            void MultiDrawArrays(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 first, ref Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* first_ptr = &first)
                    fixed (Int32* count_ptr = &count)
                    {
                        Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawArraysEXT")]
            public static 
            unsafe void MultiDrawArrays(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* first, Int32* count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)first, (Int32*)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements(OpenTK.Graphics.ES30.All mode, Int32[] count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32[] count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32[] count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32[] count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32[] count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements(OpenTK.Graphics.ES30.All mode, ref Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, ref Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, ref Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, ref Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, ref Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements(OpenTK.Graphics.ES30.All mode, Int32* count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32* count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32* count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32* count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.All mode, Int32* count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32[] count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, ref Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count_ptr, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multi_draw_arrays]
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="drawcount">
            /// <para>
            /// Specifies the size of the count and indices arrays.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_multi_draw_arrays", Version = "", EntryPoint = "glMultiDrawElementsEXT")]
            public static 
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32* count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32*)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_marker]</summary>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glPopGroupMarkerEXT")]
            public static 
            void PopGroupMarker()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glPopGroupMarkerEXT();
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose parameter to modify.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to modify.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// Specifies the new value of the parameter specified by pname for program.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            public static 
            void ProgramParameter(Int32 program, OpenTK.Graphics.ES30.All pname, Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose parameter to modify.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to modify.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// Specifies the new value of the parameter specified by pname for program.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            public static 
            void ProgramParameter(Int32 program, OpenTK.Graphics.ES30.ProgramParameterName pname, Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose parameter to modify.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to modify.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// Specifies the new value of the parameter specified by pname for program.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            public static 
            void ProgramParameter(UInt32 program, OpenTK.Graphics.ES30.All pname, Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify a parameter for a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose parameter to modify.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the name of the parameter to modify.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// Specifies the new value of the parameter specified by pname for program.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramParameteriEXT")]
            public static 
            void ProgramParameter(UInt32 program, OpenTK.Graphics.ES30.ProgramParameterName pname, Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.ES30.ProgramParameterName)pname, (Int32)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Single v0)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1fEXT((UInt32)program, (Int32)location, (Single)v0);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Single v0)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1fEXT((UInt32)program, (Int32)location, (Single)v0);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static 
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Int32 v0)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1iEXT((UInt32)program, (Int32)location, (Int32)v0);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 v0)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1iEXT((UInt32)program, (Int32)location, (Int32)v0);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static 
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uiEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, UInt32 v0)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1uiEXT((UInt32)program, (Int32)location, (UInt32)v0);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = value)
                    {
                        Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static 
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static 
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            public static 
            void ProgramUniform2(Int32 program, Int32 location, Single v0, Single v1)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Single v0, Single v1)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static 
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            public static 
            void ProgramUniform2(Int32 program, Int32 location, Int32 v0, Int32 v1)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 v0, Int32 v1)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static 
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static 
            unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static 
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uiEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, UInt32 v0, UInt32 v1)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = value)
                    {
                        Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static 
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static 
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Single v0, Single v1, Single v2)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Single v0, Single v1, Single v2)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static 
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static 
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uiEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = value)
                    {
                        Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static 
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static 
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Single v0, Single v1, Single v2, Single v3)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static 
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = value)
                    {
                        Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static 
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uiEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2, (UInt32)v3);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = value)
                    {
                        Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static 
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* value_ptr = &value)
                    {
                        Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Specify the value of a uniform variable for a specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program containing the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// For the vector commands (glProgramUniform*v), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.
            /// </para>
            /// <para>
            /// For the matrix commands (glProgramUniformMatrix*), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
            /// </para>
            /// </param>
            /// <param name="transpose">
            /// <para>
            /// For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            /// <param name="value">
            /// <para>
            /// For the vector and matrix commands, specifies a pointer to an array of count values that will be used to update the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static 
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects|EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects|EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static 
            unsafe void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_debug_marker]</summary>
            [AutoGenerated(Category = "EXT_debug_marker", Version = "", EntryPoint = "glPushGroupMarkerEXT")]
            public static 
            void PushGroupMarker(Int32 length, String marker)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glPushGroupMarkerEXT((Int32)length, (String)marker);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specify the name of a query object into which to record the GL time.
            /// </para>
            /// </param>
            /// <param name="target">
            /// <para>
            /// Specify the counter to query. target must be GL_TIMESTAMP.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glQueryCounterEXT")]
            public static 
            void QueryCounter(Int32 id, OpenTK.Graphics.ES30.All target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glQueryCounterEXT((UInt32)id, (OpenTK.Graphics.ES30.All)target);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_disjoint_timer_query]
            /// Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specify the name of a query object into which to record the GL time.
            /// </para>
            /// </param>
            /// <param name="target">
            /// <para>
            /// Specify the counter to query. target must be GL_TIMESTAMP.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_disjoint_timer_query", Version = "", EntryPoint = "glQueryCounterEXT")]
            public static 
            void QueryCounter(UInt32 id, OpenTK.Graphics.ES30.All target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glQueryCounterEXT((UInt32)id, (OpenTK.Graphics.ES30.All)target);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multiview_draw_buffers]</summary>
            [AutoGenerated(Category = "EXT_multiview_draw_buffers", Version = "", EntryPoint = "glReadBufferIndexedEXT")]
            public static 
            void ReadBufferIndexed(OpenTK.Graphics.ES30.All src, Int32 index)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glReadBufferIndexedEXT((OpenTK.Graphics.ES30.All)src, (Int32)index);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static 
            void ReadnPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, Int32 bufSize, [OutAttribute] IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glReadnPixelsEXT((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (Int32)bufSize, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static 
            void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[] data)
                where T7 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadnPixelsEXT((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (Int32)bufSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static 
            void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[,] data)
                where T7 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadnPixelsEXT((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (Int32)bufSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static 
            void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, Int32 bufSize, [InAttribute, OutAttribute] T7[,,] data)
                where T7 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadnPixelsEXT((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (Int32)bufSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_robustness]</summary>
            [AutoGenerated(Category = "EXT_robustness", Version = "", EntryPoint = "glReadnPixelsEXT")]
            public static 
            void ReadnPixels<T7>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, Int32 bufSize, [InAttribute, OutAttribute] ref T7 data)
                where T7 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadnPixelsEXT((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (Int32)bufSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T7)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleEXT")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleEXT((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleEXT")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleEXT((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a one-dimensional texture
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specify the target of the operation. target must be either GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="levels">
            /// <para>
            /// Specify the number of texture levels.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the sized internal format to be used to store texture image data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture, in texels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage1DEXT")]
            public static 
            void TexStorage1D(OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexStorage1DEXT((OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specify the target of the operation. target must be one of GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="levels">
            /// <para>
            /// Specify the number of texture levels.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the sized internal format to be used to store texture image data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture, in texels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage2DEXT")]
            public static 
            void TexStorage2D(OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexStorage2DEXT((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specify the target of the operation. target must be one of GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="levels">
            /// <para>
            /// Specify the number of texture levels.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the sized internal format to be used to store texture image data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture, in texels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage2DEXT")]
            public static 
            void TexStorage2D(OpenTK.Graphics.ES30.TextureTarget2d target, Int32 levels, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexStorage2DEXT((OpenTK.Graphics.ES30.TextureTarget2d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specify the target of the operation. target must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_ARRAY.
            /// </para>
            /// </param>
            /// <param name="levels">
            /// <para>
            /// Specify the number of texture levels.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the sized internal format to be used to store texture image data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture, in texels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage3DEXT")]
            public static 
            void TexStorage3D(OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexStorage3DEXT((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]
            /// Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specify the target of the operation. target must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_ARRAY.
            /// </para>
            /// </param>
            /// <param name="levels">
            /// <para>
            /// Specify the number of texture levels.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the sized internal format to be used to store texture image data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture, in texels.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture, in texels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTexStorage3DEXT")]
            public static 
            void TexStorage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 levels, OpenTK.Graphics.ES30.SizedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexStorage3DEXT((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)levels, (OpenTK.Graphics.ES30.SizedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage1DEXT")]
            public static 
            void TextureStorage1D(Int32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage1DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage1DEXT")]
            public static 
            void TextureStorage1D(UInt32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage1DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage2DEXT")]
            public static 
            void TextureStorage2D(Int32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage2DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage2DEXT")]
            public static 
            void TextureStorage2D(UInt32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage2DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage3DEXT")]
            public static 
            void TextureStorage3D(Int32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage3DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width, (Int32)height, (Int32)depth);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_texture_storage]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_texture_storage", Version = "", EntryPoint = "glTextureStorage3DEXT")]
            public static 
            void TextureStorage3D(UInt32 texture, OpenTK.Graphics.ES30.All target, Int32 levels, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTextureStorage3DEXT((UInt32)texture, (OpenTK.Graphics.ES30.All)target, (Int32)levels, (OpenTK.Graphics.ES30.All)internalformat, (Int32)width, (Int32)height, (Int32)depth);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind stages of a program object to a program pipeline
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the program pipeline object to which to bind stages from program.
            /// </para>
            /// </param>
            /// <param name="stages">
            /// <para>
            /// Specifies a set of program stages to bind to the program pipeline object.
            /// </para>
            /// </param>
            /// <param name="program">
            /// <para>
            /// Specifies the program object containing the shader executables to use in pipeline.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseProgramStagesEXT")]
            public static 
            void UseProgramStages(Int32 pipeline, Int32 stages, Int32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUseProgramStagesEXT((UInt32)pipeline, (UInt32)stages, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Bind stages of a program object to a program pipeline
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the program pipeline object to which to bind stages from program.
            /// </para>
            /// </param>
            /// <param name="stages">
            /// <para>
            /// Specifies a set of program stages to bind to the program pipeline object.
            /// </para>
            /// </param>
            /// <param name="program">
            /// <para>
            /// Specifies the program object containing the shader executables to use in pipeline.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseProgramStagesEXT")]
            public static 
            void UseProgramStages(UInt32 pipeline, UInt32 stages, UInt32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUseProgramStagesEXT((UInt32)pipeline, (UInt32)stages, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseShaderProgramEXT")]
            public static 
            void UseShaderProgram(OpenTK.Graphics.ES30.All type, Int32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUseShaderProgramEXT((OpenTK.Graphics.ES30.All)type, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glUseShaderProgramEXT")]
            public static 
            void UseShaderProgram(OpenTK.Graphics.ES30.All type, UInt32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUseShaderProgramEXT((OpenTK.Graphics.ES30.All)type, (UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Validate a program pipeline object against current GL state
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object to validate.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glValidateProgramPipelineEXT")]
            public static 
            void ValidateProgramPipeline(Int32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glValidateProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_separate_shader_objects]
            /// Validate a program pipeline object against current GL state
            /// </summary>
            /// <param name="pipeline">
            /// <para>
            /// Specifies the name of a program pipeline object to validate.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_separate_shader_objects", Version = "", EntryPoint = "glValidateProgramPipelineEXT")]
            public static 
            void ValidateProgramPipeline(UInt32 pipeline)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glValidateProgramPipelineEXT((UInt32)pipeline);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "EXT_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorEXT")]
            public static 
            void VertexAttribDivisor(Int32 index, Int32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorEXT((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: EXT_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "EXT_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorEXT")]
            public static 
            void VertexAttribDivisor(UInt32 index, UInt32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorEXT((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Img
        {
            /// <summary>[requires: IMG_multisampled_render_to_texture]</summary>
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleIMG")]
            public static 
            void FramebufferTexture2DMultisample(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, Int32 texture, Int32 level, Int32 samples)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture2DMultisampleIMG((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)samples);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: IMG_multisampled_render_to_texture]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glFramebufferTexture2DMultisampleIMG")]
            public static 
            void FramebufferTexture2DMultisample(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, UInt32 texture, Int32 level, Int32 samples)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture2DMultisampleIMG((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)samples);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: IMG_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleIMG")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleIMG((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: IMG_multisampled_render_to_texture]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IMG_multisampled_render_to_texture", Version = "", EntryPoint = "glRenderbufferStorageMultisampleIMG")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleIMG((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Khr
        {
            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// <para>
            /// The address of a callback function that will be called when a debug message is generated.
            /// </para>
            /// </param>
            /// <param name="userParam">
            /// <para>
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static 
            void DebugMessageCallback(DebugProcKhr callback, IntPtr userParam)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageCallbackKHR((DebugProcKhr)callback, (IntPtr)userParam);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// <para>
            /// The address of a callback function that will be called when a debug message is generated.
            /// </para>
            /// </param>
            /// <param name="userParam">
            /// <para>
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static 
            void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[] userParam)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
                try
                {
                    Delegates.glDebugMessageCallbackKHR((DebugProcKhr)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    userParam_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// <para>
            /// The address of a callback function that will be called when a debug message is generated.
            /// </para>
            /// </param>
            /// <param name="userParam">
            /// <para>
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static 
            void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[,] userParam)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
                try
                {
                    Delegates.glDebugMessageCallbackKHR((DebugProcKhr)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    userParam_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// <para>
            /// The address of a callback function that will be called when a debug message is generated.
            /// </para>
            /// </param>
            /// <param name="userParam">
            /// <para>
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static 
            void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] T1[,,] userParam)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
                try
                {
                    Delegates.glDebugMessageCallbackKHR((DebugProcKhr)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    userParam_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Specify a callback to receive debugging messages from the GL
            /// </summary>
            /// <param name="callback">
            /// <para>
            /// The address of a callback function that will be called when a debug message is generated.
            /// </para>
            /// </param>
            /// <param name="userParam">
            /// <para>
            /// A user supplied pointer that will be passed on each invocation of callback.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageCallbackKHR")]
            public static 
            void DebugMessageCallback<T1>(DebugProcKhr callback, [InAttribute, OutAttribute] ref T1 userParam)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle userParam_ptr = GCHandle.Alloc(userParam, GCHandleType.Pinned);
                try
                {
                    Delegates.glDebugMessageCallbackKHR((DebugProcKhr)callback, (IntPtr)userParam_ptr.AddrOfPinnedObject());
                    userParam = (T1)userParam_ptr.Target;
                }
                finally
                {
                    userParam_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, Int32[] ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, ref Int32 ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = &ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            unsafe void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, Int32* ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, UInt32[] ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, ref UInt32 ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = &ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            unsafe void DebugMessageControl(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, OpenTK.Graphics.ES30.All severity, Int32 count, UInt32* ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, Int32[] ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, ref Int32 ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* ids_ptr = &ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            unsafe void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, Int32* ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, UInt32[] ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, ref UInt32 ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* ids_ptr = &ids)
                    {
                        Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids_ptr, (bool)enabled);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Control the reporting of debug messages in a debug context
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of debug messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The length of the array ids.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
            /// </para>
            /// </param>
            /// <param name="enabled">
            /// <para>
            /// A Boolean flag determining whether the selected messages should be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageControlKHR")]
            public static 
            unsafe void DebugMessageControl(OpenTK.Graphics.ES30.DebugSourceControl source, OpenTK.Graphics.ES30.DebugTypeControl type, OpenTK.Graphics.ES30.DebugSeverityControl severity, Int32 count, UInt32* ids, bool enabled)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageControlKHR((OpenTK.Graphics.ES30.DebugSourceControl)source, (OpenTK.Graphics.ES30.DebugTypeControl)type, (OpenTK.Graphics.ES30.DebugSeverityControl)severity, (Int32)count, (UInt32*)ids, (bool)enabled);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message to insert.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the debug message insert.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The user-supplied identifier of the message to insert.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of the debug messages to insert.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length string contained in the character array whose address is given by message.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The address of a character array containing the message to insert.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            public static 
            void DebugMessageInsert(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, Int32 id, OpenTK.Graphics.ES30.All severity, Int32 length, String buf)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageInsertKHR((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message to insert.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the debug message insert.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The user-supplied identifier of the message to insert.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of the debug messages to insert.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length string contained in the character array whose address is given by message.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The address of a character array containing the message to insert.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            public static 
            void DebugMessageInsert(OpenTK.Graphics.ES30.All source, OpenTK.Graphics.ES30.All type, UInt32 id, OpenTK.Graphics.ES30.All severity, Int32 length, String buf)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageInsertKHR((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message to insert.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the debug message insert.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The user-supplied identifier of the message to insert.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of the debug messages to insert.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length string contained in the character array whose address is given by message.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The address of a character array containing the message to insert.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            public static 
            void DebugMessageInsert(OpenTK.Graphics.ES30.DebugSourceExternal source, OpenTK.Graphics.ES30.DebugType type, Int32 id, OpenTK.Graphics.ES30.DebugSeverity severity, Int32 length, String buf)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageInsertKHR((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Inject an application-supplied message into the debug message queue
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message to insert.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the debug message insert.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The user-supplied identifier of the message to insert.
            /// </para>
            /// </param>
            /// <param name="severity">
            /// <para>
            /// The severity of the debug messages to insert.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length string contained in the character array whose address is given by message.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The address of a character array containing the message to insert.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glDebugMessageInsertKHR")]
            public static 
            void DebugMessageInsert(OpenTK.Graphics.ES30.DebugSourceExternal source, OpenTK.Graphics.ES30.DebugType type, UInt32 id, OpenTK.Graphics.ES30.DebugSeverity severity, Int32 length, String buf)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDebugMessageInsertKHR((OpenTK.Graphics.ES30.DebugSourceExternal)source, (OpenTK.Graphics.ES30.DebugType)type, (UInt32)id, (OpenTK.Graphics.ES30.DebugSeverity)severity, (Int32)length, (String)buf);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All[] sources, [OutAttribute] OpenTK.Graphics.ES30.All[] types, [OutAttribute] Int32[] ids, [OutAttribute] OpenTK.Graphics.ES30.All[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* sources_ptr = sources)
                    fixed (OpenTK.Graphics.ES30.All* types_ptr = types)
                    fixed (Int32* ids_ptr = ids)
                    fixed (OpenTK.Graphics.ES30.All* severities_ptr = severities)
                    fixed (Int32* lengths_ptr = lengths)
                    {
                        return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.All sources, [OutAttribute] out OpenTK.Graphics.ES30.All types, [OutAttribute] out Int32 ids, [OutAttribute] out OpenTK.Graphics.ES30.All severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* sources_ptr = &sources)
                    fixed (OpenTK.Graphics.ES30.All* types_ptr = &types)
                    fixed (Int32* ids_ptr = &ids)
                    fixed (OpenTK.Graphics.ES30.All* severities_ptr = &severities)
                    fixed (Int32* lengths_ptr = &lengths)
                    {
                        Int32 retval = Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                        sources = *sources_ptr;
                        types = *types_ptr;
                        ids = *ids_ptr;
                        severities = *severities_ptr;
                        lengths = *lengths_ptr;
                        return retval;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All* sources, [OutAttribute] OpenTK.Graphics.ES30.All* types, [OutAttribute] Int32* ids, [OutAttribute] OpenTK.Graphics.ES30.All* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal[] sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType[] types, [OutAttribute] Int32[] ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = sources)
                    fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = types)
                    fixed (Int32* ids_ptr = ids)
                    fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = severities)
                    fixed (Int32* lengths_ptr = lengths)
                    {
                        return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.DebugSourceExternal sources, [OutAttribute] out OpenTK.Graphics.ES30.DebugType types, [OutAttribute] out Int32 ids, [OutAttribute] out OpenTK.Graphics.ES30.DebugSeverity severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = &sources)
                    fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = &types)
                    fixed (Int32* ids_ptr = &ids)
                    fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = &severities)
                    fixed (Int32* lengths_ptr = &lengths)
                    {
                        Int32 retval = Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                        sources = *sources_ptr;
                        types = *types_ptr;
                        ids = *ids_ptr;
                        severities = *severities_ptr;
                        lengths = *lengths_ptr;
                        return retval;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            unsafe Int32 GetDebugMessageLog(Int32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal* sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType* types, [OutAttribute] Int32* ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All[] sources, [OutAttribute] OpenTK.Graphics.ES30.All[] types, [OutAttribute] UInt32[] ids, [OutAttribute] OpenTK.Graphics.ES30.All[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* sources_ptr = sources)
                    fixed (OpenTK.Graphics.ES30.All* types_ptr = types)
                    fixed (UInt32* ids_ptr = ids)
                    fixed (OpenTK.Graphics.ES30.All* severities_ptr = severities)
                    fixed (Int32* lengths_ptr = lengths)
                    {
                        return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.All sources, [OutAttribute] out OpenTK.Graphics.ES30.All types, [OutAttribute] out UInt32 ids, [OutAttribute] out OpenTK.Graphics.ES30.All severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* sources_ptr = &sources)
                    fixed (OpenTK.Graphics.ES30.All* types_ptr = &types)
                    fixed (UInt32* ids_ptr = &ids)
                    fixed (OpenTK.Graphics.ES30.All* severities_ptr = &severities)
                    fixed (Int32* lengths_ptr = &lengths)
                    {
                        Int32 retval = Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                        sources = *sources_ptr;
                        types = *types_ptr;
                        ids = *ids_ptr;
                        severities = *severities_ptr;
                        lengths = *lengths_ptr;
                        return retval;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.All* sources, [OutAttribute] OpenTK.Graphics.ES30.All* types, [OutAttribute] UInt32* ids, [OutAttribute] OpenTK.Graphics.ES30.All* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal[] sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType[] types, [OutAttribute] UInt32[] ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity[] severities, [OutAttribute] Int32[] lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = sources)
                    fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = types)
                    fixed (UInt32* ids_ptr = ids)
                    fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = severities)
                    fixed (Int32* lengths_ptr = lengths)
                    {
                        return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] out OpenTK.Graphics.ES30.DebugSourceExternal sources, [OutAttribute] out OpenTK.Graphics.ES30.DebugType types, [OutAttribute] out UInt32 ids, [OutAttribute] out OpenTK.Graphics.ES30.DebugSeverity severities, [OutAttribute] out Int32 lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DebugSourceExternal* sources_ptr = &sources)
                    fixed (OpenTK.Graphics.ES30.DebugType* types_ptr = &types)
                    fixed (UInt32* ids_ptr = &ids)
                    fixed (OpenTK.Graphics.ES30.DebugSeverity* severities_ptr = &severities)
                    fixed (Int32* lengths_ptr = &lengths)
                    {
                        Int32 retval = Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources_ptr, (OpenTK.Graphics.ES30.DebugType*)types_ptr, (UInt32*)ids_ptr, (OpenTK.Graphics.ES30.DebugSeverity*)severities_ptr, (Int32*)lengths_ptr, (StringBuilder)messageLog);
                        sources = *sources_ptr;
                        types = *types_ptr;
                        ids = *ids_ptr;
                        severities = *severities_ptr;
                        lengths = *lengths_ptr;
                        return retval;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve messages from the debug message log
            /// </summary>
            /// <param name="count">
            /// <para>
            /// The number of debug messages to retrieve from the log.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The size of the buffer whose address is given by messageLog.
            /// </para>
            /// </param>
            /// <param name="sources">
            /// <para>
            /// The address of an array of variables to receive the sources of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The address of an array of variables to receive the types of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="severities">
            /// <para>
            /// The address of an array of variables to receive the severites of the retrieved messages.
            /// </para>
            /// </param>
            /// <param name="lengths">
            /// <para>
            /// The address of an array of variables to receive the lengths of the received messages.
            /// </para>
            /// </param>
            /// <param name="messageLog">
            /// <para>
            /// The address of an array of characters that will receive the messages.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetDebugMessageLogKHR")]
            public static 
            unsafe Int32 GetDebugMessageLog(UInt32 count, Int32 bufSize, [OutAttribute] OpenTK.Graphics.ES30.DebugSourceExternal* sources, [OutAttribute] OpenTK.Graphics.ES30.DebugType* types, [OutAttribute] UInt32* ids, [OutAttribute] OpenTK.Graphics.ES30.DebugSeverity* severities, [OutAttribute] Int32* lengths, [OutAttribute] StringBuilder messageLog)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glGetDebugMessageLogKHR((UInt32)count, (Int32)bufSize, (OpenTK.Graphics.ES30.DebugSourceExternal*)sources, (OpenTK.Graphics.ES30.DebugType*)types, (UInt32*)ids, (OpenTK.Graphics.ES30.DebugSeverity*)severities, (Int32*)lengths, (StringBuilder)messageLog);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectLabelKHR")]
            public static 
            unsafe void GetObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            unsafe void GetObjectPtrLabel(IntPtr ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr, (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                            length = *length_ptr;
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                            length = *length_ptr;
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                            length = *length_ptr;
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                            ptr = (T0)ptr_ptr.Target;
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)label);
                            ptr = (T0)ptr_ptr.Target;
                            length = *length_ptr;
                        }
                        finally
                        {
                            ptr_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Retrieve the label of a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// The name of the sync object whose label to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// The length of the buffer whose address is in label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The address of a variable to receive the length of the object label.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string that will receive the object label.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetObjectPtrLabelKHR")]
            public static 
            unsafe void GetObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)bufSize, (Int32*)length, (StringBuilder)label);
                    ptr = (T0)ptr_ptr.Target;
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]</summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static 
            void GetPointer(OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetPointervKHR((OpenTK.Graphics.ES30.All)pname, (IntPtr)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]</summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static 
            void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointervKHR((OpenTK.Graphics.ES30.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]</summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static 
            void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointervKHR((OpenTK.Graphics.ES30.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]</summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static 
            void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointervKHR((OpenTK.Graphics.ES30.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]</summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glGetPointervKHR")]
            public static 
            void GetPointer<T1>(OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointervKHR((OpenTK.Graphics.ES30.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    @params = (T1)@params_ptr.Target;
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object to label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            public static 
            void ObjectLabel(OpenTK.Graphics.ES30.All identifier, Int32 name, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object to label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            public static 
            void ObjectLabel(OpenTK.Graphics.ES30.All identifier, UInt32 name, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object to label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            public static 
            void ObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, Int32 name, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a named object identified within a namespace
            /// </summary>
            /// <param name="identifier">
            /// <para>
            /// The namespace from which the name of the object is allocated.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// The name of the object to label.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectLabelKHR")]
            public static 
            void ObjectLabel(OpenTK.Graphics.ES30.ObjectLabelIdentifier identifier, UInt32 name, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glObjectLabelKHR((OpenTK.Graphics.ES30.ObjectLabelIdentifier)identifier, (UInt32)name, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// A pointer identifying a sync object.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static 
            void ObjectPtrLabel(IntPtr ptr, Int32 length, String label)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glObjectPtrLabelKHR((IntPtr)ptr, (Int32)length, (String)label);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// A pointer identifying a sync object.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static 
            void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[] ptr, Int32 length, String label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// A pointer identifying a sync object.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static 
            void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,] ptr, Int32 length, String label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// A pointer identifying a sync object.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static 
            void ObjectPtrLabel<T0>([InAttribute, OutAttribute] T0[,,] ptr, Int32 length, String label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Label a a sync object identified by a pointer
            /// </summary>
            /// <param name="ptr">
            /// <para>
            /// A pointer identifying a sync object.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the label to be used for the object.
            /// </para>
            /// </param>
            /// <param name="label">
            /// <para>
            /// The address of a string containing the label to assign to the object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glObjectPtrLabelKHR")]
            public static 
            void ObjectPtrLabel<T0>([InAttribute, OutAttribute] ref T0 ptr, Int32 length, String label)
                where T0 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle ptr_ptr = GCHandle.Alloc(ptr, GCHandleType.Pinned);
                try
                {
                    Delegates.glObjectPtrLabelKHR((IntPtr)ptr_ptr.AddrOfPinnedObject(), (Int32)length, (String)label);
                    ptr = (T0)ptr_ptr.Target;
                }
                finally
                {
                    ptr_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Pop the active debug group
            /// </summary>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPopDebugGroupKHR")]
            public static 
            void PopDebugGroup()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glPopDebugGroupKHR();
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Push a named debug group into the command stream
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The identifier of the message.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the message to be sent to the debug output stream.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The a string containing the message to be sent to the debug output stream.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroupKHR")]
            public static 
            void PushDebugGroup(OpenTK.Graphics.ES30.All source, Int32 id, Int32 length, String message)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glPushDebugGroupKHR((OpenTK.Graphics.ES30.All)source, (UInt32)id, (Int32)length, (String)message);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: KHR_debug]
            /// Push a named debug group into the command stream
            /// </summary>
            /// <param name="source">
            /// <para>
            /// The source of the debug message.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// The identifier of the message.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// The length of the message to be sent to the debug output stream.
            /// </para>
            /// </param>
            /// <param name="message">
            /// <para>
            /// The a string containing the message to be sent to the debug output stream.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "KHR_debug", Version = "", EntryPoint = "glPushDebugGroupKHR")]
            public static 
            void PushDebugGroup(OpenTK.Graphics.ES30.All source, UInt32 id, Int32 length, String message)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glPushDebugGroupKHR((OpenTK.Graphics.ES30.All)source, (UInt32)id, (Int32)length, (String)message);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class NV
        {
            /// <summary>[requires: NV_blend_equation_advanced]</summary>
            [AutoGenerated(Category = "NV_blend_equation_advanced", Version = "", EntryPoint = "glBlendBarrierNV")]
            public static 
            void BlendBarrier()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlendBarrierNV();
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_blend_equation_advanced]</summary>
            [AutoGenerated(Category = "NV_blend_equation_advanced", Version = "", EntryPoint = "glBlendParameteriNV")]
            public static 
            void BlendParameter(OpenTK.Graphics.ES30.All pname, Int32 value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlendParameteriNV((OpenTK.Graphics.ES30.All)pname, (Int32)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// <para>
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </para>
            /// </param>
            /// <param name="dstX0">
            /// <para>
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
            /// </para>
            /// </param>
            /// <param name="filter">
            /// <para>
            /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferNV")]
            public static 
            void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.All mask, OpenTK.Graphics.ES30.All filter)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlitFramebufferNV((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_framebuffer_blit]
            /// Copy a block of pixels from the read framebuffer to the draw framebuffer
            /// </summary>
            /// <param name="srcX0">
            /// <para>
            /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
            /// </para>
            /// </param>
            /// <param name="dstX0">
            /// <para>
            /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
            /// </para>
            /// </param>
            /// <param name="filter">
            /// <para>
            /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_framebuffer_blit", Version = "", EntryPoint = "glBlitFramebufferNV")]
            public static 
            void BlitFramebuffer(Int32 srcX0, Int32 srcY0, Int32 srcX1, Int32 srcY1, Int32 dstX0, Int32 dstY0, Int32 dstX1, Int32 dstY1, OpenTK.Graphics.ES30.ClearBufferMask mask, OpenTK.Graphics.ES30.BlitFramebufferFilter filter)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBlitFramebufferNV((Int32)srcX0, (Int32)srcY0, (Int32)srcX1, (Int32)srcY1, (Int32)dstX0, (Int32)dstY0, (Int32)dstX1, (Int32)dstY1, (OpenTK.Graphics.ES30.ClearBufferMask)mask, (OpenTK.Graphics.ES30.BlitFramebufferFilter)filter);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_copy_buffer]
            /// Copy part of the data store of a buffer object to the data store of another buffer object
            /// </summary>
            /// <param name="readtarget">
            /// <para>
            /// Specifies the target from whose data store data should be read.
            /// </para>
            /// </param>
            /// <param name="writetarget">
            /// <para>
            /// Specifies the target to whose data store data should be written.
            /// </para>
            /// </param>
            /// <param name="readoffset">
            /// <para>
            /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
            /// </para>
            /// </param>
            /// <param name="writeoffset">
            /// <para>
            /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_copy_buffer", Version = "", EntryPoint = "glCopyBufferSubDataNV")]
            public static 
            void CopyBufferSubData(OpenTK.Graphics.ES30.All readTarget, OpenTK.Graphics.ES30.All writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyBufferSubDataNV((OpenTK.Graphics.ES30.BufferTarget)readTarget, (OpenTK.Graphics.ES30.BufferTarget)writeTarget, (IntPtr)readOffset, (IntPtr)writeOffset, (IntPtr)size);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_copy_buffer]
            /// Copy part of the data store of a buffer object to the data store of another buffer object
            /// </summary>
            /// <param name="readtarget">
            /// <para>
            /// Specifies the target from whose data store data should be read.
            /// </para>
            /// </param>
            /// <param name="writetarget">
            /// <para>
            /// Specifies the target to whose data store data should be written.
            /// </para>
            /// </param>
            /// <param name="readoffset">
            /// <para>
            /// Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.
            /// </para>
            /// </param>
            /// <param name="writeoffset">
            /// <para>
            /// Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_copy_buffer", Version = "", EntryPoint = "glCopyBufferSubDataNV")]
            public static 
            void CopyBufferSubData(OpenTK.Graphics.ES30.BufferTarget readTarget, OpenTK.Graphics.ES30.BufferTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyBufferSubDataNV((OpenTK.Graphics.ES30.BufferTarget)readTarget, (OpenTK.Graphics.ES30.BufferTarget)writeTarget, (IntPtr)readOffset, (IntPtr)writeOffset, (IntPtr)size);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_coverage_sample]</summary>
            [AutoGenerated(Category = "NV_coverage_sample", Version = "", EntryPoint = "glCoverageMaskNV")]
            public static 
            void CoverageMask(bool mask)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCoverageMaskNV((bool)mask);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_coverage_sample]</summary>
            [AutoGenerated(Category = "NV_coverage_sample", Version = "", EntryPoint = "glCoverageOperationNV")]
            public static 
            void CoverageOperation(OpenTK.Graphics.ES30.All operation)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCoverageOperationNV((OpenTK.Graphics.ES30.All)operation);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFence(Int32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* fences_ptr = (UInt32*)&fences;
                    Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFence(UInt32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* fences_ptr = (UInt32*)&fences;
                    Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFences(Int32 n, Int32[] fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* fences_ptr = fences)
                    {
                        Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFences(Int32 n, ref Int32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* fences_ptr = &fences)
                    {
                        Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            unsafe void DeleteFences(Int32 n, Int32* fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFences(Int32 n, UInt32[] fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* fences_ptr = fences)
                    {
                        Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            void DeleteFences(Int32 n, ref UInt32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* fences_ptr = &fences)
                    {
                        Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glDeleteFencesNV")]
            public static 
            unsafe void DeleteFences(Int32 n, UInt32* fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawArraysInstancedNV")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.All mode, Int32 first, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a range of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawArraysInstancedNV")]
            public static 
            void DrawArraysInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 first, Int32 count, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawArraysInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)first, (Int32)count, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All[] bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* bufs_ptr = bufs)
                    {
                        Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.All bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.All* bufs_ptr = &bufs)
                    {
                        Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.All* bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode[] bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = bufs)
                    {
                        Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.ES30.DrawBufferMode bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (OpenTK.Graphics.ES30.DrawBufferMode* bufs_ptr = &bufs)
                    {
                        Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_buffers]
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_draw_buffers", Version = "", EntryPoint = "glDrawBuffersNV")]
            public static 
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.ES30.DrawBufferMode* bufs)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawBuffersNV((Int32)n, (OpenTK.Graphics.ES30.DrawBufferMode*)bufs);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.All mode, Int32 count, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_draw_instanced]
            /// Draw multiple instances of a set of elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the number of instances of the specified range of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_draw_instanced", Version = "", EntryPoint = "glDrawElementsInstancedNV")]
            public static 
            void DrawElementsInstanced<T3>(OpenTK.Graphics.ES30.PrimitiveType mode, Int32 count, OpenTK.Graphics.ES30.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedNV((OpenTK.Graphics.ES30.PrimitiveType)mode, (Int32)count, (OpenTK.Graphics.ES30.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glFinishFenceNV")]
            public static 
            void FinishFence(Int32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFinishFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glFinishFenceNV")]
            public static 
            void FinishFence(UInt32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFinishFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            Int32 GenFence()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    Int32 retval;
                    Int32* fences_ptr = &retval;
                    Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            void GenFences(Int32 n, [OutAttribute] Int32[] fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* fences_ptr = fences)
                    {
                        Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            void GenFences(Int32 n, [OutAttribute] out Int32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* fences_ptr = &fences)
                    {
                        Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                        fences = *fences_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            unsafe void GenFences(Int32 n, [OutAttribute] Int32* fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenFencesNV((Int32)n, (UInt32*)fences);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            void GenFences(Int32 n, [OutAttribute] UInt32[] fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* fences_ptr = fences)
                    {
                        Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            void GenFences(Int32 n, [OutAttribute] out UInt32 fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* fences_ptr = &fences)
                    {
                        Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                        fences = *fences_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGenFencesNV")]
            public static 
            unsafe void GenFences(Int32 n, [OutAttribute] UInt32* fences)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenFencesNV((Int32)n, (UInt32*)fences);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            void GetFence(Int32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            void GetFence(Int32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            unsafe void GetFence(Int32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            void GetFence(UInt32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            void GetFence(UInt32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glGetFenceivNV")]
            public static 
            unsafe void GetFence(UInt32 fence, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glIsFenceNV")]
            public static 
            bool IsFence(Int32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glIsFenceNV")]
            public static 
            bool IsFence(UInt32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_read_buffer]
            /// Select a color buffer source for pixels
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_read_buffer", Version = "", EntryPoint = "glReadBufferNV")]
            public static 
            void ReadBuffer(OpenTK.Graphics.ES30.All mode)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glReadBufferNV((OpenTK.Graphics.ES30.All)mode);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "NV_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleNV")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.All target, Int32 samples, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleNV((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_framebuffer_multisample]
            /// Establish data storage, format, dimensions and sample count of a renderbuffer object's image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.
            /// </para>
            /// </param>
            /// <param name="samples">
            /// <para>
            /// Specifies the number of samples to be used for the renderbuffer object's storage.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format to use for the renderbuffer object's image.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the renderbuffer, in pixels.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_framebuffer_multisample", Version = "", EntryPoint = "glRenderbufferStorageMultisampleNV")]
            public static 
            void RenderbufferStorageMultisample(OpenTK.Graphics.ES30.RenderbufferTarget target, Int32 samples, OpenTK.Graphics.ES30.RenderbufferInternalFormat internalformat, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glRenderbufferStorageMultisampleNV((OpenTK.Graphics.ES30.RenderbufferTarget)target, (Int32)samples, (OpenTK.Graphics.ES30.RenderbufferInternalFormat)internalformat, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glSetFenceNV")]
            public static 
            void SetFence(Int32 fence, OpenTK.Graphics.ES30.All condition)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glSetFenceNV((UInt32)fence, (OpenTK.Graphics.ES30.All)condition);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glSetFenceNV")]
            public static 
            void SetFence(UInt32 fence, OpenTK.Graphics.ES30.All condition)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glSetFenceNV((UInt32)fence, (OpenTK.Graphics.ES30.All)condition);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glTestFenceNV")]
            public static 
            bool TestFence(Int32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glTestFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_fence]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_fence", Version = "", EntryPoint = "glTestFenceNV")]
            public static 
            bool TestFence(UInt32 fence)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glTestFenceNV((UInt32)fence);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            public static 
            void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix2x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            public static 
            void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix2x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x3fvNV")]
            public static 
            unsafe void UniformMatrix2x3(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix2x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            public static 
            void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix2x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            public static 
            void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix2x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix2x4fvNV")]
            public static 
            unsafe void UniformMatrix2x4(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix2x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            public static 
            void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix3x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            public static 
            void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix3x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x2fvNV")]
            public static 
            unsafe void UniformMatrix3x2(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix3x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            public static 
            void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix3x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            public static 
            void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix3x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix3x4fvNV")]
            public static 
            unsafe void UniformMatrix3x4(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix3x4fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            public static 
            void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix4x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            public static 
            void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix4x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x2fvNV")]
            public static 
            unsafe void UniformMatrix4x2(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix4x2fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            public static 
            void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, Single[] value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = value)
                    {
                        Delegates.glUniformMatrix4x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            public static 
            void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, ref Single value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Single* value_ptr = &value)
                    {
                        Delegates.glUniformMatrix4x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_non_square_matrices]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_non_square_matrices", Version = "", EntryPoint = "glUniformMatrix4x3fvNV")]
            public static 
            unsafe void UniformMatrix4x3(Int32 location, Int32 count, bool transpose, Single* value)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glUniformMatrix4x3fvNV((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NV_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorNV")]
            public static 
            void VertexAttribDivisor(Int32 index, Int32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorNV((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: NV_instanced_arrays]
            /// Modify the rate at which generic vertex attributes advance during instanced rendering
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specify the index of the generic vertex attribute.
            /// </para>
            /// </param>
            /// <param name="divisor">
            /// <para>
            /// Specify the number of instances that will pass between updates of the generic attribute at slot index.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NV_instanced_arrays", Version = "", EntryPoint = "glVertexAttribDivisorNV")]
            public static 
            void VertexAttribDivisor(UInt32 index, UInt32 divisor)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glVertexAttribDivisorNV((UInt32)index, (UInt32)divisor);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Oes
        {
            /// <summary>[requires: OES_vertex_array_object]
            /// Bind a vertex array object
            /// </summary>
            /// <param name="array">
            /// <para>
            /// Specifies the name of the vertex array to bind.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glBindVertexArrayOES")]
            public static 
            void BindVertexArray(Int32 array)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBindVertexArrayOES((UInt32)array);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Bind a vertex array object
            /// </summary>
            /// <param name="array">
            /// <para>
            /// Specifies the name of the vertex array to bind.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glBindVertexArrayOES")]
            public static 
            void BindVertexArray(UInt32 array)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glBindVertexArrayOES((UInt32)array);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T8)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexImage3DOES")]
            public static 
            void CompressedTexImage3D<T8>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.CompressedInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
                where T8 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.CompressedInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T8)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,,] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T10 data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T10)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, IntPtr data)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] T10[,,] data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCompressedTexSubImage3DOES")]
            public static 
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, Int32 imageSize, [InAttribute, OutAttribute] ref T10 data)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                {
                    Delegates.glCompressedTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    data = (T10)data_ptr.Target;
                }
                finally
                {
                    data_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Copy a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCopyTexSubImage3DOES")]
            public static 
            void CopyTexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Copy a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glCopyTexSubImage3DOES")]
            public static 
            void CopyTexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glCopyTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]</summary>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArray(Int32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* arrays_ptr = (UInt32*)&arrays;
                    Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArray(UInt32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    UInt32* arrays_ptr = (UInt32*)&arrays;
                    Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArrays(Int32 n, Int32[] arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* arrays_ptr = arrays)
                    {
                        Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArrays(Int32 n, ref Int32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* arrays_ptr = &arrays)
                    {
                        Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            unsafe void DeleteVertexArrays(Int32 n, Int32* arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArrays(Int32 n, UInt32[] arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* arrays_ptr = arrays)
                    {
                        Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            void DeleteVertexArrays(Int32 n, ref UInt32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* arrays_ptr = &arrays)
                    {
                        Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Delete vertex array objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies the address of an array containing the n names of the objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glDeleteVertexArraysOES")]
            public static 
            unsafe void DeleteVertexArrays(Int32 n, UInt32* arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDeleteVertexArraysOES((Int32)n, (UInt32*)arrays);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_EGL_image]</summary>
            [AutoGenerated(Category = "OES_EGL_image", Version = "", EntryPoint = "glEGLImageTargetRenderbufferStorageOES")]
            public static 
            void EGLImageTargetRenderbufferStorage(OpenTK.Graphics.ES30.All target, IntPtr image)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEGLImageTargetRenderbufferStorageOES((OpenTK.Graphics.ES30.All)target, (IntPtr)image);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_EGL_image]</summary>
            [AutoGenerated(Category = "OES_EGL_image", Version = "", EntryPoint = "glEGLImageTargetTexture2DOES")]
            public static 
            void EGLImageTargetTexture2D(OpenTK.Graphics.ES30.All target, IntPtr image)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEGLImageTargetTexture2DOES((OpenTK.Graphics.ES30.All)target, (IntPtr)image);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]</summary>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glFramebufferTexture3DOES")]
            public static 
            void FramebufferTexture3D(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, Int32 texture, Int32 level, Int32 zoffset)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture3DOES((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glFramebufferTexture3DOES")]
            public static 
            void FramebufferTexture3D(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All attachment, OpenTK.Graphics.ES30.All textarget, UInt32 texture, Int32 level, Int32 zoffset)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glFramebufferTexture3DOES((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)attachment, (OpenTK.Graphics.ES30.All)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]</summary>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            Int32 GenVertexArray()
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    const Int32 n = 1;
                    Int32 retval;
                    Int32* arrays_ptr = &retval;
                    Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    return retval;
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            void GenVertexArrays(Int32 n, [OutAttribute] Int32[] arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* arrays_ptr = arrays)
                    {
                        Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            void GenVertexArrays(Int32 n, [OutAttribute] out Int32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* arrays_ptr = &arrays)
                    {
                        Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                        arrays = *arrays_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            unsafe void GenVertexArrays(Int32 n, [OutAttribute] Int32* arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            void GenVertexArrays(Int32 n, [OutAttribute] UInt32[] arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* arrays_ptr = arrays)
                    {
                        Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            void GenVertexArrays(Int32 n, [OutAttribute] out UInt32 arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* arrays_ptr = &arrays)
                    {
                        Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays_ptr);
                        arrays = *arrays_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Generate vertex array object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of vertex array object names to generate.
            /// </para>
            /// </param>
            /// <param name="arrays">
            /// <para>
            /// Specifies an array in which the generated vertex array object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glGenVertexArraysOES")]
            public static 
            unsafe void GenVertexArrays(Int32 n, [OutAttribute] UInt32* arrays)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGenVertexArraysOES((Int32)n, (UInt32*)arrays);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [OutAttribute] IntPtr @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    @params = (T2)@params_ptr.Target;
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [OutAttribute] IntPtr @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glGetBufferPointervOES")]
            public static 
            void GetBufferPointer<T2>(OpenTK.Graphics.ES30.BufferTarget target, OpenTK.Graphics.ES30.BufferPointer pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetBufferPointervOES((OpenTK.Graphics.ES30.BufferTarget)target, (OpenTK.Graphics.ES30.BufferPointer)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    @params = (T2)@params_ptr.Target;
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            binary = (T4)binary_ptr.Target;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                            binary = (T4)binary_ptr.Target;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(Int32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                    binary = (T4)binary_ptr.Target;
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] OpenTK.Graphics.ES30.All[] binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            binary = (T4)binary_ptr.Target;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary);
                        length = *length_ptr;
                        binaryFormat = *binaryFormat_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (OpenTK.Graphics.ES30.All* binaryFormat_ptr = &binaryFormat)
                    {
                        GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length_ptr, (OpenTK.Graphics.ES30.All*)binaryFormat_ptr, (IntPtr)binary_ptr.AddrOfPinnedObject());
                            length = *length_ptr;
                            binaryFormat = *binaryFormat_ptr;
                            binary = (T4)binary_ptr.Target;
                        }
                        finally
                        {
                            binary_ptr.Free();
                        }
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [OutAttribute] IntPtr binary)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] T4[,,] binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Return a binary representation of a program object's compiled and linked executable source
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object whose binary representation to retrieve.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the buffer whose address is given by binary.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the address of a variable to receive the number of bytes written into binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array into which the GL will return program's binary representation.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glGetProgramBinaryOES")]
            public static 
            unsafe void GetProgramBinary<T4>(UInt32 program, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] OpenTK.Graphics.ES30.All* binaryFormat, [InAttribute, OutAttribute] ref T4 binary)
                where T4 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetProgramBinaryOES((UInt32)program, (Int32)bufSize, (Int32*)length, (OpenTK.Graphics.ES30.All*)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject());
                    binary = (T4)binary_ptr.Target;
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Determine if a name corresponds to a vertex array object
            /// </summary>
            /// <param name="array">
            /// <para>
            /// Specifies a value that may be the name of a vertex array object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glIsVertexArrayOES")]
            public static 
            bool IsVertexArray(Int32 array)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsVertexArrayOES((UInt32)array);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_vertex_array_object]
            /// Determine if a name corresponds to a vertex array object
            /// </summary>
            /// <param name="array">
            /// <para>
            /// Specifies a value that may be the name of a vertex array object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_vertex_array_object", Version = "", EntryPoint = "glIsVertexArrayOES")]
            public static 
            bool IsVertexArray(UInt32 array)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glIsVertexArrayOES((UInt32)array);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]
            /// Map a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object being mapped. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER or GL_UNIFORM_BUFFER.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// For glMapBuffer only, specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glMapBufferOES")]
            public static 
            IntPtr MapBuffer(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All access)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glMapBufferOES((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)access);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, IntPtr binary, Int32 length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary, (Int32)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,,] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(Int32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T2 binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    binary = (T2)binary_ptr.Target;
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, IntPtr binary, Int32 length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary, (Int32)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] T2[,,] binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_get_program_binary]
            /// Load a program object with a program binary
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the name of a program object into which to load a program binary.
            /// </para>
            /// </param>
            /// <param name="binaryFormat">
            /// <para>
            /// Specifies the format of the binary data in binary.
            /// </para>
            /// </param>
            /// <param name="binary">
            /// <para>
            /// Specifies the address an array containing the binary to be loaded into program.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies the number of bytes contained in binary.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "OES_get_program_binary", Version = "", EntryPoint = "glProgramBinaryOES")]
            public static 
            void ProgramBinary<T2>(UInt32 program, OpenTK.Graphics.ES30.All binaryFormat, [InAttribute, OutAttribute] ref T2 binary, Int32 length)
                where T2 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle binary_ptr = GCHandle.Alloc(binary, GCHandleType.Pinned);
                try
                {
                    Delegates.glProgramBinaryOES((UInt32)program, (OpenTK.Graphics.ES30.All)binaryFormat, (IntPtr)binary_ptr.AddrOfPinnedObject(), (Int32)length);
                    binary = (T2)binary_ptr.Target;
                }
                finally
                {
                    binary_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.All target, Int32 level, OpenTK.Graphics.ES30.All internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T9)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, IntPtr pixels)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// This value must be 0.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexImage3DOES")]
            public static 
            void TexImage3D<T9>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, OpenTK.Graphics.ES30.TextureComponentCount internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.ES30.PixelFormat format, OpenTK.Graphics.ES30.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (OpenTK.Graphics.ES30.TextureComponentCount)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.ES30.PixelFormat)format, (OpenTK.Graphics.ES30.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T9)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T10)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, IntPtr pixels)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_texture_3D]
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "OES_texture_3D", Version = "", EntryPoint = "glTexSubImage3DOES")]
            public static 
            void TexSubImage3D<T10>(OpenTK.Graphics.ES30.TextureTarget3d target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3DOES((OpenTK.Graphics.ES30.TextureTarget3d)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T10)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [Obsolete("Use strongly-typed overload instead")]
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glUnmapBufferOES")]
            public static 
            bool UnmapBuffer(OpenTK.Graphics.ES30.All target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glUnmapBufferOES((OpenTK.Graphics.ES30.BufferTarget)target);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: OES_mapbuffer]</summary>
            [AutoGenerated(Category = "OES_mapbuffer", Version = "", EntryPoint = "glUnmapBufferOES")]
            public static 
            bool UnmapBuffer(OpenTK.Graphics.ES30.BufferTarget target)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glUnmapBufferOES((OpenTK.Graphics.ES30.BufferTarget)target);
                #if DEBUG
                }
                #endif
            }

        }

        public static partial class Qcom
        {
            /// <summary>[requires: QCOM_alpha_test]
            /// Specify the alpha test function
            /// </summary>
            /// <param name="func">
            /// <para>
            /// Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.
            /// </para>
            /// </param>
            /// <param name="ref">
            /// <para>
            /// Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "QCOM_alpha_test", Version = "", EntryPoint = "glAlphaFuncQCOM")]
            public static 
            void AlphaFunc(OpenTK.Graphics.ES30.All func, Single @ref)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glAlphaFuncQCOM((OpenTK.Graphics.ES30.All)func, (Single)@ref);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glDisableDriverControlQCOM")]
            public static 
            void DisableDriverControl(Int32 driverControl)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDisableDriverControlQCOM((UInt32)driverControl);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glDisableDriverControlQCOM")]
            public static 
            void DisableDriverControl(UInt32 driverControl)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glDisableDriverControlQCOM((UInt32)driverControl);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glEnableDriverControlQCOM")]
            public static 
            void EnableDriverControl(Int32 driverControl)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEnableDriverControlQCOM((UInt32)driverControl);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glEnableDriverControlQCOM")]
            public static 
            void EnableDriverControl(UInt32 driverControl)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEnableDriverControlQCOM((UInt32)driverControl);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glEndTilingQCOM")]
            public static 
            void EndTiling(Int32 preserveMask)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndTilingQCOM((UInt32)preserveMask);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glEndTilingQCOM")]
            public static 
            void EndTiling(UInt32 preserveMask)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glEndTilingQCOM((UInt32)preserveMask);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static 
            void ExtGetBufferPointer(OpenTK.Graphics.ES30.All target, [OutAttribute] IntPtr @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetBufferPointervQCOM((OpenTK.Graphics.ES30.All)target, (IntPtr)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static 
            void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES30.All target, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetBufferPointervQCOM((OpenTK.Graphics.ES30.All)target, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static 
            void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES30.All target, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetBufferPointervQCOM((OpenTK.Graphics.ES30.All)target, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static 
            void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES30.All target, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetBufferPointervQCOM((OpenTK.Graphics.ES30.All)target, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBufferPointervQCOM")]
            public static 
            void ExtGetBufferPointer<T1>(OpenTK.Graphics.ES30.All target, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetBufferPointervQCOM((OpenTK.Graphics.ES30.All)target, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    @params = (T1)@params_ptr.Target;
                }
                finally
                {
                    @params_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            void ExtGetBuffers([OutAttribute] Int32[] buffers, Int32 maxBuffers, [OutAttribute] Int32[] numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* buffers_ptr = buffers)
                    fixed (Int32* numBuffers_ptr = numBuffers)
                    {
                        Delegates.glExtGetBuffersQCOM((UInt32*)buffers_ptr, (Int32)maxBuffers, (Int32*)numBuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            void ExtGetBuffers([OutAttribute] out Int32 buffers, Int32 maxBuffers, [OutAttribute] out Int32 numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* buffers_ptr = &buffers)
                    fixed (Int32* numBuffers_ptr = &numBuffers)
                    {
                        Delegates.glExtGetBuffersQCOM((UInt32*)buffers_ptr, (Int32)maxBuffers, (Int32*)numBuffers_ptr);
                        buffers = *buffers_ptr;
                        numBuffers = *numBuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            unsafe void ExtGetBuffers([OutAttribute] Int32* buffers, Int32 maxBuffers, [OutAttribute] Int32* numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetBuffersQCOM((UInt32*)buffers, (Int32)maxBuffers, (Int32*)numBuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            void ExtGetBuffers([OutAttribute] UInt32[] buffers, Int32 maxBuffers, [OutAttribute] Int32[] numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* buffers_ptr = buffers)
                    fixed (Int32* numBuffers_ptr = numBuffers)
                    {
                        Delegates.glExtGetBuffersQCOM((UInt32*)buffers_ptr, (Int32)maxBuffers, (Int32*)numBuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            void ExtGetBuffers([OutAttribute] out UInt32 buffers, Int32 maxBuffers, [OutAttribute] out Int32 numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* buffers_ptr = &buffers)
                    fixed (Int32* numBuffers_ptr = &numBuffers)
                    {
                        Delegates.glExtGetBuffersQCOM((UInt32*)buffers_ptr, (Int32)maxBuffers, (Int32*)numBuffers_ptr);
                        buffers = *buffers_ptr;
                        numBuffers = *numBuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetBuffersQCOM")]
            public static 
            unsafe void ExtGetBuffers([OutAttribute] UInt32* buffers, Int32 maxBuffers, [OutAttribute] Int32* numBuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetBuffersQCOM((UInt32*)buffers, (Int32)maxBuffers, (Int32*)numBuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            void ExtGetFramebuffers([OutAttribute] Int32[] framebuffers, Int32 maxFramebuffers, [OutAttribute] Int32[] numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* framebuffers_ptr = framebuffers)
                    fixed (Int32* numFramebuffers_ptr = numFramebuffers)
                    {
                        Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers_ptr, (Int32)maxFramebuffers, (Int32*)numFramebuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            void ExtGetFramebuffers([OutAttribute] out Int32 framebuffers, Int32 maxFramebuffers, [OutAttribute] out Int32 numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* framebuffers_ptr = &framebuffers)
                    fixed (Int32* numFramebuffers_ptr = &numFramebuffers)
                    {
                        Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers_ptr, (Int32)maxFramebuffers, (Int32*)numFramebuffers_ptr);
                        framebuffers = *framebuffers_ptr;
                        numFramebuffers = *numFramebuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            unsafe void ExtGetFramebuffers([OutAttribute] Int32* framebuffers, Int32 maxFramebuffers, [OutAttribute] Int32* numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers, (Int32)maxFramebuffers, (Int32*)numFramebuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            void ExtGetFramebuffers([OutAttribute] UInt32[] framebuffers, Int32 maxFramebuffers, [OutAttribute] Int32[] numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* framebuffers_ptr = framebuffers)
                    fixed (Int32* numFramebuffers_ptr = numFramebuffers)
                    {
                        Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers_ptr, (Int32)maxFramebuffers, (Int32*)numFramebuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            void ExtGetFramebuffers([OutAttribute] out UInt32 framebuffers, Int32 maxFramebuffers, [OutAttribute] out Int32 numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* framebuffers_ptr = &framebuffers)
                    fixed (Int32* numFramebuffers_ptr = &numFramebuffers)
                    {
                        Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers_ptr, (Int32)maxFramebuffers, (Int32*)numFramebuffers_ptr);
                        framebuffers = *framebuffers_ptr;
                        numFramebuffers = *numFramebuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetFramebuffersQCOM")]
            public static 
            unsafe void ExtGetFramebuffers([OutAttribute] UInt32* framebuffers, Int32 maxFramebuffers, [OutAttribute] Int32* numFramebuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetFramebuffersQCOM((UInt32*)framebuffers, (Int32)maxFramebuffers, (Int32*)numFramebuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] Int32[] length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] out Int32 length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length_ptr);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            unsafe void ExtGetProgramBinarySource(Int32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] Int32* length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] Int32[] length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] out Int32 length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length_ptr);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramBinarySourceQCOM")]
            public static 
            unsafe void ExtGetProgramBinarySource(UInt32 program, OpenTK.Graphics.ES30.All shadertype, [OutAttribute] StringBuilder source, [OutAttribute] Int32* length)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetProgramBinarySourceQCOM((UInt32)program, (OpenTK.Graphics.ES30.All)shadertype, (StringBuilder)source, (Int32*)length);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            void ExtGetProgram([OutAttribute] Int32[] programs, Int32 maxPrograms, [OutAttribute] Int32[] numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* programs_ptr = programs)
                    fixed (Int32* numPrograms_ptr = numPrograms)
                    {
                        Delegates.glExtGetProgramsQCOM((UInt32*)programs_ptr, (Int32)maxPrograms, (Int32*)numPrograms_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            void ExtGetProgram([OutAttribute] out Int32 programs, Int32 maxPrograms, [OutAttribute] out Int32 numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* programs_ptr = &programs)
                    fixed (Int32* numPrograms_ptr = &numPrograms)
                    {
                        Delegates.glExtGetProgramsQCOM((UInt32*)programs_ptr, (Int32)maxPrograms, (Int32*)numPrograms_ptr);
                        programs = *programs_ptr;
                        numPrograms = *numPrograms_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            unsafe void ExtGetProgram([OutAttribute] Int32* programs, Int32 maxPrograms, [OutAttribute] Int32* numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetProgramsQCOM((UInt32*)programs, (Int32)maxPrograms, (Int32*)numPrograms);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            void ExtGetProgram([OutAttribute] UInt32[] programs, Int32 maxPrograms, [OutAttribute] Int32[] numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* programs_ptr = programs)
                    fixed (Int32* numPrograms_ptr = numPrograms)
                    {
                        Delegates.glExtGetProgramsQCOM((UInt32*)programs_ptr, (Int32)maxPrograms, (Int32*)numPrograms_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            void ExtGetProgram([OutAttribute] out UInt32 programs, Int32 maxPrograms, [OutAttribute] out Int32 numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* programs_ptr = &programs)
                    fixed (Int32* numPrograms_ptr = &numPrograms)
                    {
                        Delegates.glExtGetProgramsQCOM((UInt32*)programs_ptr, (Int32)maxPrograms, (Int32*)numPrograms_ptr);
                        programs = *programs_ptr;
                        numPrograms = *numPrograms_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetProgramsQCOM")]
            public static 
            unsafe void ExtGetProgram([OutAttribute] UInt32* programs, Int32 maxPrograms, [OutAttribute] Int32* numPrograms)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetProgramsQCOM((UInt32*)programs, (Int32)maxPrograms, (Int32*)numPrograms);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            void ExtGetRenderbuffers([OutAttribute] Int32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute] Int32[] numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* renderbuffers_ptr = renderbuffers)
                    fixed (Int32* numRenderbuffers_ptr = numRenderbuffers)
                    {
                        Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers_ptr, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            void ExtGetRenderbuffers([OutAttribute] out Int32 renderbuffers, Int32 maxRenderbuffers, [OutAttribute] out Int32 numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* renderbuffers_ptr = &renderbuffers)
                    fixed (Int32* numRenderbuffers_ptr = &numRenderbuffers)
                    {
                        Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers_ptr, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers_ptr);
                        renderbuffers = *renderbuffers_ptr;
                        numRenderbuffers = *numRenderbuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            unsafe void ExtGetRenderbuffers([OutAttribute] Int32* renderbuffers, Int32 maxRenderbuffers, [OutAttribute] Int32* numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            void ExtGetRenderbuffers([OutAttribute] UInt32[] renderbuffers, Int32 maxRenderbuffers, [OutAttribute] Int32[] numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* renderbuffers_ptr = renderbuffers)
                    fixed (Int32* numRenderbuffers_ptr = numRenderbuffers)
                    {
                        Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers_ptr, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            void ExtGetRenderbuffers([OutAttribute] out UInt32 renderbuffers, Int32 maxRenderbuffers, [OutAttribute] out Int32 numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* renderbuffers_ptr = &renderbuffers)
                    fixed (Int32* numRenderbuffers_ptr = &numRenderbuffers)
                    {
                        Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers_ptr, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers_ptr);
                        renderbuffers = *renderbuffers_ptr;
                        numRenderbuffers = *numRenderbuffers_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetRenderbuffersQCOM")]
            public static 
            unsafe void ExtGetRenderbuffers([OutAttribute] UInt32* renderbuffers, Int32 maxRenderbuffers, [OutAttribute] Int32* numRenderbuffers)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetRenderbuffersQCOM((UInt32*)renderbuffers, (Int32)maxRenderbuffers, (Int32*)numRenderbuffers);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            void ExtGetShaders([OutAttribute] Int32[] shaders, Int32 maxShaders, [OutAttribute] Int32[] numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* shaders_ptr = shaders)
                    fixed (Int32* numShaders_ptr = numShaders)
                    {
                        Delegates.glExtGetShadersQCOM((UInt32*)shaders_ptr, (Int32)maxShaders, (Int32*)numShaders_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            void ExtGetShaders([OutAttribute] out Int32 shaders, Int32 maxShaders, [OutAttribute] out Int32 numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* shaders_ptr = &shaders)
                    fixed (Int32* numShaders_ptr = &numShaders)
                    {
                        Delegates.glExtGetShadersQCOM((UInt32*)shaders_ptr, (Int32)maxShaders, (Int32*)numShaders_ptr);
                        shaders = *shaders_ptr;
                        numShaders = *numShaders_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            unsafe void ExtGetShaders([OutAttribute] Int32* shaders, Int32 maxShaders, [OutAttribute] Int32* numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetShadersQCOM((UInt32*)shaders, (Int32)maxShaders, (Int32*)numShaders);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            void ExtGetShaders([OutAttribute] UInt32[] shaders, Int32 maxShaders, [OutAttribute] Int32[] numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* shaders_ptr = shaders)
                    fixed (Int32* numShaders_ptr = numShaders)
                    {
                        Delegates.glExtGetShadersQCOM((UInt32*)shaders_ptr, (Int32)maxShaders, (Int32*)numShaders_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            void ExtGetShaders([OutAttribute] out UInt32 shaders, Int32 maxShaders, [OutAttribute] out Int32 numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* shaders_ptr = &shaders)
                    fixed (Int32* numShaders_ptr = &numShaders)
                    {
                        Delegates.glExtGetShadersQCOM((UInt32*)shaders_ptr, (Int32)maxShaders, (Int32*)numShaders_ptr);
                        shaders = *shaders_ptr;
                        numShaders = *numShaders_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtGetShadersQCOM")]
            public static 
            unsafe void ExtGetShaders([OutAttribute] UInt32* shaders, Int32 maxShaders, [OutAttribute] Int32* numShaders)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetShadersQCOM((UInt32*)shaders, (Int32)maxShaders, (Int32*)numShaders);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            unsafe void ExtGetTexLevelParameter(Int32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32[] @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] out Int32 @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexLevelParameterivQCOM")]
            public static 
            unsafe void ExtGetTexLevelParameter(UInt32 texture, OpenTK.Graphics.ES30.All face, Int32 level, OpenTK.Graphics.ES30.All pname, [OutAttribute] Int32* @params)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetTexLevelParameterivQCOM((UInt32)texture, (OpenTK.Graphics.ES30.All)face, (Int32)level, (OpenTK.Graphics.ES30.All)pname, (Int32*)@params);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static 
            void ExtGetTexSubImage(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [OutAttribute] IntPtr texels)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetTexSubImageQCOM((OpenTK.Graphics.ES30.All)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)texels);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static 
            void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[] texels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle texels_ptr = GCHandle.Alloc(texels, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetTexSubImageQCOM((OpenTK.Graphics.ES30.All)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)texels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    texels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static 
            void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,] texels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle texels_ptr = GCHandle.Alloc(texels, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetTexSubImageQCOM((OpenTK.Graphics.ES30.All)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)texels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    texels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static 
            void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] T10[,,] texels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle texels_ptr = GCHandle.Alloc(texels, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetTexSubImageQCOM((OpenTK.Graphics.ES30.All)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)texels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    texels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexSubImageQCOM")]
            public static 
            void ExtGetTexSubImage<T10>(OpenTK.Graphics.ES30.All target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.ES30.All format, OpenTK.Graphics.ES30.All type, [InAttribute, OutAttribute] ref T10 texels)
                where T10 : struct
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                GCHandle texels_ptr = GCHandle.Alloc(texels, GCHandleType.Pinned);
                try
                {
                    Delegates.glExtGetTexSubImageQCOM((OpenTK.Graphics.ES30.All)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.ES30.All)format, (OpenTK.Graphics.ES30.All)type, (IntPtr)texels_ptr.AddrOfPinnedObject());
                    texels = (T10)texels_ptr.Target;
                }
                finally
                {
                    texels_ptr.Free();
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            void ExtGetTextures([OutAttribute] Int32[] textures, Int32 maxTextures, [OutAttribute] Int32[] numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* textures_ptr = textures)
                    fixed (Int32* numTextures_ptr = numTextures)
                    {
                        Delegates.glExtGetTexturesQCOM((UInt32*)textures_ptr, (Int32)maxTextures, (Int32*)numTextures_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            void ExtGetTextures([OutAttribute] out Int32 textures, Int32 maxTextures, [OutAttribute] out Int32 numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* textures_ptr = &textures)
                    fixed (Int32* numTextures_ptr = &numTextures)
                    {
                        Delegates.glExtGetTexturesQCOM((UInt32*)textures_ptr, (Int32)maxTextures, (Int32*)numTextures_ptr);
                        textures = *textures_ptr;
                        numTextures = *numTextures_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            unsafe void ExtGetTextures([OutAttribute] Int32* textures, Int32 maxTextures, [OutAttribute] Int32* numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetTexturesQCOM((UInt32*)textures, (Int32)maxTextures, (Int32*)numTextures);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            void ExtGetTextures([OutAttribute] UInt32[] textures, Int32 maxTextures, [OutAttribute] Int32[] numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = textures)
                    fixed (Int32* numTextures_ptr = numTextures)
                    {
                        Delegates.glExtGetTexturesQCOM((UInt32*)textures_ptr, (Int32)maxTextures, (Int32*)numTextures_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            void ExtGetTextures([OutAttribute] out UInt32 textures, Int32 maxTextures, [OutAttribute] out Int32 numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = &textures)
                    fixed (Int32* numTextures_ptr = &numTextures)
                    {
                        Delegates.glExtGetTexturesQCOM((UInt32*)textures_ptr, (Int32)maxTextures, (Int32*)numTextures_ptr);
                        textures = *textures_ptr;
                        numTextures = *numTextures_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtGetTexturesQCOM")]
            public static 
            unsafe void ExtGetTextures([OutAttribute] UInt32* textures, Int32 maxTextures, [OutAttribute] Int32* numTextures)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtGetTexturesQCOM((UInt32*)textures, (Int32)maxTextures, (Int32*)numTextures);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtIsProgramBinaryQCOM")]
            public static 
            bool ExtIsProgramBinary(Int32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glExtIsProgramBinaryQCOM((UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get2]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_extended_get2", Version = "", EntryPoint = "glExtIsProgramBinaryQCOM")]
            public static 
            bool ExtIsProgramBinary(UInt32 program)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                return Delegates.glExtIsProgramBinaryQCOM((UInt32)program);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_extended_get]</summary>
            [AutoGenerated(Category = "QCOM_extended_get", Version = "", EntryPoint = "glExtTexObjectStateOverrideiQCOM")]
            public static 
            void ExtTexObjectStateOverride(OpenTK.Graphics.ES30.All target, OpenTK.Graphics.ES30.All pname, Int32 param)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glExtTexObjectStateOverrideiQCOM((OpenTK.Graphics.ES30.All)target, (OpenTK.Graphics.ES30.All)pname, (Int32)param);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            void GetDriverControl([OutAttribute] Int32[] num, Int32 size, [OutAttribute] Int32[] driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* num_ptr = num)
                    fixed (Int32* driverControls_ptr = driverControls)
                    {
                        Delegates.glGetDriverControlsQCOM((Int32*)num_ptr, (Int32)size, (UInt32*)driverControls_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            void GetDriverControl([OutAttribute] Int32[] num, Int32 size, [OutAttribute] UInt32[] driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* num_ptr = num)
                    fixed (UInt32* driverControls_ptr = driverControls)
                    {
                        Delegates.glGetDriverControlsQCOM((Int32*)num_ptr, (Int32)size, (UInt32*)driverControls_ptr);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            void GetDriverControl([OutAttribute] out Int32 num, Int32 size, [OutAttribute] out Int32 driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* num_ptr = &num)
                    fixed (Int32* driverControls_ptr = &driverControls)
                    {
                        Delegates.glGetDriverControlsQCOM((Int32*)num_ptr, (Int32)size, (UInt32*)driverControls_ptr);
                        num = *num_ptr;
                        driverControls = *driverControls_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            void GetDriverControl([OutAttribute] out Int32 num, Int32 size, [OutAttribute] out UInt32 driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* num_ptr = &num)
                    fixed (UInt32* driverControls_ptr = &driverControls)
                    {
                        Delegates.glGetDriverControlsQCOM((Int32*)num_ptr, (Int32)size, (UInt32*)driverControls_ptr);
                        num = *num_ptr;
                        driverControls = *driverControls_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            unsafe void GetDriverControl([OutAttribute] Int32* num, Int32 size, [OutAttribute] Int32* driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetDriverControlsQCOM((Int32*)num, (Int32)size, (UInt32*)driverControls);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlsQCOM")]
            public static 
            unsafe void GetDriverControl([OutAttribute] Int32* num, Int32 size, [OutAttribute] UInt32* driverControls)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetDriverControlsQCOM((Int32*)num, (Int32)size, (UInt32*)driverControls);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)driverControlString);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)driverControlString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            unsafe void GetDriverControlString(Int32 driverControl, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length, (StringBuilder)driverControlString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] Int32[] length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = length)
                    {
                        Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)driverControlString);
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    {
                        Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)driverControlString);
                        length = *length_ptr;
                    }
                }
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_driver_control]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_driver_control", Version = "", EntryPoint = "glGetDriverControlStringQCOM")]
            public static 
            unsafe void GetDriverControlString(UInt32 driverControl, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder driverControlString)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glGetDriverControlStringQCOM((UInt32)driverControl, (Int32)bufSize, (Int32*)length, (StringBuilder)driverControlString);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glStartTilingQCOM")]
            public static 
            void StartTiling(Int32 x, Int32 y, Int32 width, Int32 height, Int32 preserveMask)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glStartTilingQCOM((UInt32)x, (UInt32)y, (UInt32)width, (UInt32)height, (UInt32)preserveMask);
                #if DEBUG
                }
                #endif
            }

            /// <summary>[requires: QCOM_tiled_rendering]</summary>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "QCOM_tiled_rendering", Version = "", EntryPoint = "glStartTilingQCOM")]
            public static 
            void StartTiling(UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 preserveMask)
            {
                #if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
                #endif
                Delegates.glStartTilingQCOM((UInt32)x, (UInt32)y, (UInt32)width, (UInt32)height, (UInt32)preserveMask);
                #if DEBUG
                }
                #endif
            }

        }

    }
}
